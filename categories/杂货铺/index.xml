<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>杂货铺 on 养猪场</title>
    <link>https://zhixiangyuan.github.io/categories/%E6%9D%82%E8%B4%A7%E9%93%BA/</link>
    <description>Recent content in 杂货铺 on 养猪场</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>yuanzx</copyright>
    <lastBuildDate>Fri, 28 Feb 2020 10:31:53 +0800</lastBuildDate>
    
	<atom:link href="https://zhixiangyuan.github.io/categories/%E6%9D%82%E8%B4%A7%E9%93%BA/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Git 提交如何关联到 Issue</title>
      <link>https://zhixiangyuan.github.io/2020/02/28/git-%E6%8F%90%E4%BA%A4%E5%A6%82%E4%BD%95%E5%85%B3%E8%81%94%E5%88%B0-issue/</link>
      <pubDate>Fri, 28 Feb 2020 10:31:53 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/28/git-%E6%8F%90%E4%BA%A4%E5%A6%82%E4%BD%95%E5%85%B3%E8%81%94%E5%88%B0-issue/</guid>
      <description>github 会做自动关联，需要在 commit 中提及 issue，建议使用下面的语法 1 $&amp;gt; git commit -m &amp;#34;Fix: #&amp;lt;$issue_id&amp;gt; &amp;lt;$commemt_content&amp;gt;&amp;#34;</description>
    </item>
    
    <item>
      <title>include 中使用 &lt;&gt; 和 &#34;&#34; 的区别</title>
      <link>https://zhixiangyuan.github.io/2020/02/27/include-%E4%B8%AD%E4%BD%BF%E7%94%A8-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Thu, 27 Feb 2020 17:37:45 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/27/include-%E4%B8%AD%E4%BD%BF%E7%94%A8-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>1 2 3 4 5 6 // 使用 &amp;lt;&amp;gt; 表示先从系统环境变量下面寻找，如果没找到再去当前目录寻找 #include &amp;lt;stdio.h&amp;gt;// 使用 &amp;#34;&amp;#34; 表示先从当前目录下寻找，如果没找到再去环境变量下寻找 #include</description>
    </item>
    
    <item>
      <title>查看最常使用的 10 条 linux 命令</title>
      <link>https://zhixiangyuan.github.io/2020/02/27/%E6%9F%A5%E7%9C%8B%E6%9C%80%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84-10-%E6%9D%A1-linux-%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Thu, 27 Feb 2020 14:39:57 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/27/%E6%9F%A5%E7%9C%8B%E6%9C%80%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84-10-%E6%9D%A1-linux-%E5%91%BD%E4%BB%A4/</guid>
      <description>在终端中输入如下命令即可看到您最常使用的 10 条命令 1 2 3 4 5 6 7 8 9 10 11 12 13 $&amp;gt; history | awk &amp;#39;{print $2}&amp;#39; | sort | uniq -c | sort -rn | head -10 # 下面是我的输出结果 1432 cd 1384 git 1250 ll</description>
    </item>
    
    <item>
      <title>/etc/passwd</title>
      <link>https://zhixiangyuan.github.io/2020/02/27/etc/passwd/</link>
      <pubDate>Thu, 27 Feb 2020 10:51:01 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/27/etc/passwd/</guid>
      <description>该文件用于存放用户的一些信息，文件中的每一行便是一个用户的信息，每种信息之间用 : 进行分隔。总共有七种信息，下面的例子是我系统中 root 的信息，每种</description>
    </item>
    
    <item>
      <title>kafka 发送消息分区选择策略</title>
      <link>https://zhixiangyuan.github.io/2020/02/18/kafka-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%88%86%E5%8C%BA%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5/</link>
      <pubDate>Tue, 18 Feb 2020 13:51:46 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/18/kafka-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%88%86%E5%8C%BA%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5/</guid>
      <description>1 大体逻辑 partition 的分区选择发生在发送数据的生产者上面，在选择分区时分为两种情况 消息的 key 为 null 那么则获取该 topic 的一个随机数，然后判断 topic 的可用分区数是否</description>
    </item>
    
    <item>
      <title>kafka-client 使用示例</title>
      <link>https://zhixiangyuan.github.io/2020/02/17/kafka-client-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Mon, 17 Feb 2020 09:38:22 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/17/kafka-client-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</guid>
      <description>1 生产者示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import org.apache.kafka.clients.producer.KafkaProducer; import org.apache.kafka.clients.producer.Producer; import org.apache.kafka.clients.producer.ProducerRecord; import org.apache.kafka.clients.producer.RecordMetadata; import org.apache.kafka.common.serialization.StringSerializer; import java.util.Properties;</description>
    </item>
    
    <item>
      <title>使用命令行脚本操作 kafka 小记</title>
      <link>https://zhixiangyuan.github.io/2020/02/16/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%84%9A%E6%9C%AC%E6%93%8D%E4%BD%9C-kafka-%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Sun, 16 Feb 2020 22:25:01 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/16/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%84%9A%E6%9C%AC%E6%93%8D%E4%BD%9C-kafka-%E5%B0%8F%E8%AE%B0/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 # 启动命令 $&amp;gt; bin/kafka-server-start.sh &amp;lt;$config_file_path&amp;gt; ## demo: 启动命令 $&amp;gt; bin/kafka-server-start.sh config/server.properties # 终止命令 $&amp;gt; bin/kafka-server-stop.sh &amp;lt;$config_file_path&amp;gt; ## demo: 终</description>
    </item>
    
    <item>
      <title>修复 Google Guava 框架的 CaseFormat 类中的 Bug</title>
      <link>https://zhixiangyuan.github.io/2020/02/16/%E4%BF%AE%E5%A4%8D-google-guava-%E6%A1%86%E6%9E%B6%E7%9A%84-caseformat-%E7%B1%BB%E4%B8%AD%E7%9A%84-bug/</link>
      <pubDate>Sun, 16 Feb 2020 18:50:21 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/16/%E4%BF%AE%E5%A4%8D-google-guava-%E6%A1%86%E6%9E%B6%E7%9A%84-caseformat-%E7%B1%BB%E4%B8%AD%E7%9A%84-bug/</guid>
      <description>CaseFormat 可以很方便地实现字符串驼峰转下划线的功能，内部的实现原理是寻找需要做转换的字母处，然后将其字母前方的单词做截取，再根据转换后的字符串需求做</description>
    </item>
    
    <item>
      <title>开源 BoostPOI 框架</title>
      <link>https://zhixiangyuan.github.io/2020/02/16/%E5%BC%80%E6%BA%90-boostpoi-%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Sun, 16 Feb 2020 18:13:21 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/16/%E5%BC%80%E6%BA%90-boostpoi-%E6%A1%86%E6%9E%B6/</guid>
      <description>这个框架的诞生是由于当时接收到公司的一个任务，需要去使用 poi 做关于统计的表格，在接到任务之后我便研究了一下 poi 的用法，发现在直接使用的时候会暴露</description>
    </item>
    
    <item>
      <title>并发工具类小记</title>
      <link>https://zhixiangyuan.github.io/2020/02/15/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Sat, 15 Feb 2020 22:40:50 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/15/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B0%8F%E8%AE%B0/</guid>
      <description>1 Semaphore Semaphore 的作用是限制获取锁的线程数量，常用的 synchronized、ReentrantLock 均只能让一个线程进入代码块，而 Semaphore 可以允许同时有</description>
    </item>
    
    <item>
      <title>Google 云配置 SSH 为公网可登陆</title>
      <link>https://zhixiangyuan.github.io/2020/02/14/google-%E4%BA%91%E9%85%8D%E7%BD%AE-ssh-%E4%B8%BA%E5%85%AC%E7%BD%91%E5%8F%AF%E7%99%BB%E9%99%86/</link>
      <pubDate>Fri, 14 Feb 2020 21:43:55 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/14/google-%E4%BA%91%E9%85%8D%E7%BD%AE-ssh-%E4%B8%BA%E5%85%AC%E7%BD%91%E5%8F%AF%E7%99%BB%E9%99%86/</guid>
      <description>1 使用浏览器 SSH 登陆服务器 使用 sudo -i 切换到 root 用户 vi /etc/ssh/sshd_config 修改配置文件 修改以下两项配置为 yes PermitRootLogin yes // 默认为 no，需要开启 root 用户访问改为 yes PasswordAuthentication yes // 默认为 no，</description>
    </item>
    
    <item>
      <title>IDEA 中非常好用的插件</title>
      <link>https://zhixiangyuan.github.io/2020/02/12/idea-%E4%B8%AD%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Wed, 12 Feb 2020 21:22:10 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/12/idea-%E4%B8%AD%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/</guid>
      <description>1 自动生成时序图插件：SequenceDiagram 在插件库中直接搜索 SequenceDiagram 即可找到该插件 使用时直接在方法上右击即可找到生成时序图选项 然后选择一</description>
    </item>
    
    <item>
      <title>类初始化的加载顺序</title>
      <link>https://zhixiangyuan.github.io/2020/02/12/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>Wed, 12 Feb 2020 16:01:53 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/12/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</guid>
      <description>类初始化时候的加载顺序是首先加载父类的静态代码，静态代码的加载顺序从上向下执行，然后加载子类的静态代码，同样从上向下执行。 在初始化实例的时候</description>
    </item>
    
    <item>
      <title>如何使用 qq 语音定位好友的位置</title>
      <link>https://zhixiangyuan.github.io/2020/02/11/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-qq-%E8%AF%AD%E9%9F%B3%E5%AE%9A%E4%BD%8D%E5%A5%BD%E5%8F%8B%E7%9A%84%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Tue, 11 Feb 2020 22:50:10 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/11/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-qq-%E8%AF%AD%E9%9F%B3%E5%AE%9A%E4%BD%8D%E5%A5%BD%E5%8F%8B%E7%9A%84%E4%BD%8D%E7%BD%AE/</guid>
      <description>首先，这里的原理是和好友语音，那么会首先从腾讯服务器获取到对方的 IP 地址，然后再本地连线对方，那么我们在这里进行抓包便可以知道对方的 IP 地址。抓</description>
    </item>
    
    <item>
      <title>如何安装 gitbook 插件</title>
      <link>https://zhixiangyuan.github.io/2020/02/10/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85-gitbook-%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Mon, 10 Feb 2020 16:14:26 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/10/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85-gitbook-%E6%8F%92%E4%BB%B6/</guid>
      <description>安装 Gitbook 插件，本来是一件很简单的事情，在 book.json 文件加入插件相关的信息，比如下面的 mathjax 插件，然后运行 gitbook install 即可完成安装。 1 2 3 { &amp;#34;plugins&amp;#34;: [&amp;#34;mathjax&amp;#34;] } 不过由于众所周知的</description>
    </item>
    
    <item>
      <title>Leetcode: 64 最小路径和</title>
      <link>https://zhixiangyuan.github.io/2020/02/08/leetcode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</link>
      <pubDate>Sat, 08 Feb 2020 14:13:57 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/08/leetcode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</guid>
      <description>1 题目 最小路径和 2 解 2.1 动态规划 遍历一遍数组就出答案 从最后一个格子开始遍历，一直向前加数值，直到加到 [0,0] 的位置，然后取出 [0,0] 内部存储的数据。 1 2 3</description>
    </item>
    
    <item>
      <title>Leetcode: 63 不同路径 II</title>
      <link>https://zhixiangyuan.github.io/2020/02/07/leetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-ii/</link>
      <pubDate>Fri, 07 Feb 2020 21:00:28 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/07/leetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-ii/</guid>
      <description>1 题目 不同路径 II 2 解 2.1 模拟移动 这个方法跑数据集会超时 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { // 从 [0, 0] 节点</description>
    </item>
    
    <item>
      <title>Leetcode: 6 不同路径</title>
      <link>https://zhixiangyuan.github.io/2020/02/07/leetcode-6-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Fri, 07 Feb 2020 13:30:49 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/07/leetcode-6-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</guid>
      <description>1 题目 不同路径 2 解 2.1 使用排列组合的解法 本题其实是一个排列组合问题，由于只能向下和向右移动，所以最终会移动 (n - 1) + (m - 1) 步，假设 n - 1 是向下移</description>
    </item>
    
    <item>
      <title>排列组合公式</title>
      <link>https://zhixiangyuan.github.io/2020/02/07/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E5%85%AC%E5%BC%8F/</link>
      <pubDate>Fri, 07 Feb 2020 11:45:46 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/07/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E5%85%AC%E5%BC%8F/</guid>
      <description>1 对于排列公式的理解 第一步，从 n 个元素中选取 1 个，有 n 种选择方式 第二步，从剩下的 n - 1 个元素中选取 1 个，有 n - 1 种选择方式 第三步，从剩下的 n</description>
    </item>
    
    <item>
      <title>给定数组的中心下标和数据长度来计算开始下标和结束下标</title>
      <link>https://zhixiangyuan.github.io/2020/02/06/%E7%BB%99%E5%AE%9A%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87%E5%92%8C%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6%E6%9D%A5%E8%AE%A1%E7%AE%97%E5%BC%80%E5%A7%8B%E4%B8%8B%E6%A0%87%E5%92%8C%E7%BB%93%E6%9D%9F%E4%B8%8B%E6%A0%87/</link>
      <pubDate>Thu, 06 Feb 2020 15:19:38 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/06/%E7%BB%99%E5%AE%9A%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87%E5%92%8C%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6%E6%9D%A5%E8%AE%A1%E7%AE%97%E5%BC%80%E5%A7%8B%E4%B8%8B%E6%A0%87%E5%92%8C%E7%BB%93%E6%9D%9F%E4%B8%8B%E6%A0%87/</guid>
      <description>给定数组下标 index 与数据长度 len 1 2 3 4 5 下标的计算公式是 end = index + len/2 start = index - (len - 1)/2 不过这套公式只能应对偶数时 index 的中心点在左边的情况 下面计算示例 1 2</description>
    </item>
    
    <item>
      <title>单台服务器可以支撑多少的 tcp 连接</title>
      <link>https://zhixiangyuan.github.io/2020/02/01/%E5%8D%95%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E6%94%AF%E6%92%91%E5%A4%9A%E5%B0%91%E7%9A%84-tcp-%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Sat, 01 Feb 2020 14:28:22 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/01/%E5%8D%95%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E6%94%AF%E6%92%91%E5%A4%9A%E5%B0%91%E7%9A%84-tcp-%E8%BF%9E%E6%8E%A5/</guid>
      <description>一般我们都是在 Linux 系统下使用服务端，那么这个问题主要和 linux 系统挂钩。 从理论上 tcp 连接与四元组有关，那么只有四元组当中的一项发生改变，那么便可以建立</description>
    </item>
    
    <item>
      <title>分布式事务小记</title>
      <link>https://zhixiangyuan.github.io/2020/02/01/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Sat, 01 Feb 2020 11:08:42 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/01/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%B0%8F%E8%AE%B0/</guid>
      <description>分布式事务解决的核心问题是数据一致性的问题，根据 cap 理论可知一致性、可用性、分区容错性三者只能选其二，所以在实践中需要对此做出权衡。目前解决分</description>
    </item>
    
    <item>
      <title>Netty 中从 PooledByteBufAllocator 分配直接内存的逻辑</title>
      <link>https://zhixiangyuan.github.io/2020/01/30/netty-%E4%B8%AD%E4%BB%8E-pooledbytebufallocator-%E5%88%86%E9%85%8D%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E7%9A%84%E9%80%BB%E8%BE%91/</link>
      <pubDate>Thu, 30 Jan 2020 15:38:21 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/30/netty-%E4%B8%AD%E4%BB%8E-pooledbytebufallocator-%E5%88%86%E9%85%8D%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E7%9A%84%E9%80%BB%E8%BE%91/</guid>
      <description>从 PooledByteBufAllocator 中分配直接内存会调用 newDirectBuffer 方法，该方法会先从 ThreadLocal 中取出 PoolThreadCache，如果取得时候没有则创建一个新的 PoolThreadCac</description>
    </item>
    
    <item>
      <title>如何运用位运算判断某个数是否是二的幂次</title>
      <link>https://zhixiangyuan.github.io/2020/01/30/%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E6%98%AF%E4%BA%8C%E7%9A%84%E5%B9%82%E6%AC%A1/</link>
      <pubDate>Thu, 30 Jan 2020 14:20:35 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/30/%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E6%98%AF%E4%BA%8C%E7%9A%84%E5%B9%82%E6%AC%A1/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 判断是否是 2 的幂次 public static boolean isPowerOfTwo(int num) { return (num &amp;amp; num - 1) == 0; } // 测试用例 public static void main(String[] args) { for (int i = 0; i &amp;lt; 100; i++) { if (isPowerOfTwo(i)) {</description>
    </item>
    
    <item>
      <title>如何用与运算实现对 2 的幂次的数的取余</title>
      <link>https://zhixiangyuan.github.io/2020/01/29/%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%8E%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%AF%B9-2-%E7%9A%84%E5%B9%82%E6%AC%A1%E7%9A%84%E6%95%B0%E7%9A%84%E5%8F%96%E4%BD%99/</link>
      <pubDate>Wed, 29 Jan 2020 19:51:53 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/29/%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%8E%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%AF%B9-2-%E7%9A%84%E5%B9%82%E6%AC%A1%E7%9A%84%E6%95%B0%E7%9A%84%E5%8F%96%E4%BD%99/</guid>
      <description>比如说想要对 4 取余，那么下面这段代码便可以做到 1 2 3 public static int mod4(int num) { return num &amp;amp; 0b0000_0011; } 对一个 2 的幂次的数做取余操作可以使用下面的这套公式 1 2 3 public static int mod4(int num)</description>
    </item>
    
    <item>
      <title>异或运算小技巧</title>
      <link>https://zhixiangyuan.github.io/2020/01/29/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E5%B0%8F%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Wed, 29 Jan 2020 15:06:53 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/29/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E5%B0%8F%E6%8A%80%E5%B7%A7/</guid>
      <description>1 自己与自己运算得到 0 1 2 3 4 // 当 x = y 时， x ^ y = 0 public static int method(int x, int y) { return x ^ y; } 2 在一定条件下使用异或实现减法效果 1 2 3 4 5 6 7 8 9 10 11 // 假</description>
    </item>
    
    <item>
      <title>通过异或实现偶数加一奇数减一的效果</title>
      <link>https://zhixiangyuan.github.io/2020/01/29/%E9%80%9A%E8%BF%87%E5%BC%82%E6%88%96%E5%AE%9E%E7%8E%B0%E5%81%B6%E6%95%B0%E5%8A%A0%E4%B8%80%E5%A5%87%E6%95%B0%E5%87%8F%E4%B8%80%E7%9A%84%E6%95%88%E6%9E%9C/</link>
      <pubDate>Wed, 29 Jan 2020 13:31:58 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/29/%E9%80%9A%E8%BF%87%E5%BC%82%E6%88%96%E5%AE%9E%E7%8E%B0%E5%81%B6%E6%95%B0%E5%8A%A0%E4%B8%80%E5%A5%87%E6%95%B0%E5%87%8F%E4%B8%80%E7%9A%84%E6%95%88%E6%9E%9C/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 计算逻辑是位运算，非常高效 // 同时这种计算方法可用于计算使用数组存储的完全二叉</description>
    </item>
    
    <item>
      <title>使用数组构造完全二叉树</title>
      <link>https://zhixiangyuan.github.io/2020/01/27/%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E6%9E%84%E9%80%A0%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 27 Jan 2020 19:06:37 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/27/%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E6%9E%84%E9%80%A0%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * 创建一颗树高为 treeHeight 的完全二叉树 * * @param treeHeight 树高 * @return 以数组形式存储的完全二</description>
    </item>
    
    <item>
      <title>Netty 中对于小于 512 判断的优化</title>
      <link>https://zhixiangyuan.github.io/2020/01/27/netty-%E4%B8%AD%E5%AF%B9%E4%BA%8E%E5%B0%8F%E4%BA%8E-512-%E5%88%A4%E6%96%AD%E7%9A%84%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 27 Jan 2020 16:53:46 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/27/netty-%E4%B8%AD%E5%AF%B9%E4%BA%8E%E5%B0%8F%E4%BA%8E-512-%E5%88%A4%E6%96%AD%E7%9A%84%E4%BC%98%E5%8C%96/</guid>
      <description>在日常编程中，对于 num &amp;lt; 512 是一个很正常的写法，但是 &amp;lt; 终究没有位运算速度快，所以 Netty 对于这个运算也作出了优化实现，下面看该优化实现 1 2 3 4 5 6 7 8</description>
    </item>
    
    <item>
      <title>Netty 对于 ThreadLocal 的优化</title>
      <link>https://zhixiangyuan.github.io/2020/01/27/netty-%E5%AF%B9%E4%BA%8E-threadlocal-%E7%9A%84%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 27 Jan 2020 12:58:11 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/27/netty-%E5%AF%B9%E4%BA%8E-threadlocal-%E7%9A%84%E4%BC%98%E5%8C%96/</guid>
      <description>对于 ThreadLocal 这个使用起来很方便的线程级别的全局变量，其本身有两点是需要注意的 第一，它在线程池的环境中使用时是可能会导致内存泄漏的，这一点如果大家不</description>
    </item>
    
    <item>
      <title>计算距离大于某数的最近的 2 的幂次的数</title>
      <link>https://zhixiangyuan.github.io/2020/01/26/%E8%AE%A1%E7%AE%97%E8%B7%9D%E7%A6%BB%E5%A4%A7%E4%BA%8E%E6%9F%90%E6%95%B0%E7%9A%84%E6%9C%80%E8%BF%91%E7%9A%84-2-%E7%9A%84%E5%B9%82%E6%AC%A1%E7%9A%84%E6%95%B0/</link>
      <pubDate>Sun, 26 Jan 2020 23:28:24 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/26/%E8%AE%A1%E7%AE%97%E8%B7%9D%E7%A6%BB%E5%A4%A7%E4%BA%8E%E6%9F%90%E6%95%B0%E7%9A%84%E6%9C%80%E8%BF%91%E7%9A%84-2-%E7%9A%84%E5%B9%82%E6%AC%A1%E7%9A%84%E6%95%B0/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /** 计算大于 n 的最近的 2 的幂次的数 */ public static int method1(int n) { int newCapacity = n; newCapacity |= newCapacity &amp;gt;&amp;gt;&amp;gt; 1; newCapacity |= newCapacity &amp;gt;&amp;gt;&amp;gt;</description>
    </item>
    
    <item>
      <title>分析 Netty 中基于 ThreadLocal 的对象池</title>
      <link>https://zhixiangyuan.github.io/2020/01/26/%E5%88%86%E6%9E%90-netty-%E4%B8%AD%E5%9F%BA%E4%BA%8E-threadlocal-%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0/</link>
      <pubDate>Sun, 26 Jan 2020 19:39:28 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/26/%E5%88%86%E6%9E%90-netty-%E4%B8%AD%E5%9F%BA%E4%BA%8E-threadlocal-%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0/</guid>
      <description>1 对象池原理简述 Netty 中提供的对象池使用起来非常简单，在使用的时候只需要关注两个点，一是需要实现相应的 newObject 对象的方法，毕竟对象池里面放置什么对象是</description>
    </item>
    
    <item>
      <title>Netty 是如何检测是否有新连接接入？又如何对新连接进行接入？</title>
      <link>https://zhixiangyuan.github.io/2020/01/24/netty-%E6%98%AF%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E6%9C%89%E6%96%B0%E8%BF%9E%E6%8E%A5%E6%8E%A5%E5%85%A5%E5%8F%88%E5%A6%82%E4%BD%95%E5%AF%B9%E6%96%B0%E8%BF%9E%E6%8E%A5%E8%BF%9B%E8%A1%8C%E6%8E%A5%E5%85%A5/</link>
      <pubDate>Fri, 24 Jan 2020 15:04:33 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/24/netty-%E6%98%AF%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E6%9C%89%E6%96%B0%E8%BF%9E%E6%8E%A5%E6%8E%A5%E5%85%A5%E5%8F%88%E5%A6%82%E4%BD%95%E5%AF%B9%E6%96%B0%E8%BF%9E%E6%8E%A5%E8%BF%9B%E8%A1%8C%E6%8E%A5%E5%85%A5/</guid>
      <description>1 如何检测是否有新连接接入 一般对于服务端，我们会 new 两个 NioEventLoopGroup，一个我们称为 bossGroup，另一个称为 work</description>
    </item>
    
    <item>
      <title>Netty 服务端起多少个线程？何时启动 EventLoop？</title>
      <link>https://zhixiangyuan.github.io/2020/01/23/netty-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B5%B7%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BD%95%E6%97%B6%E5%90%AF%E5%8A%A8-eventloop/</link>
      <pubDate>Thu, 23 Jan 2020 22:53:44 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/23/netty-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B5%B7%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BD%95%E6%97%B6%E5%90%AF%E5%8A%A8-eventloop/</guid>
      <description>1 Netty 服务端起多少个线程 一般我们都是直接去 new NioEventLoopGroup，通过跟踪 NioEventLoopGroup 的构造方法能够发现以下的代码 1 2 3 4 5 6 7 8 9 10 11 12</description>
    </item>
    
    <item>
      <title>Netty 对于 Selector 的 KeySet 的优化</title>
      <link>https://zhixiangyuan.github.io/2020/01/23/netty-%E5%AF%B9%E4%BA%8E-selector-%E7%9A%84-keyset-%E7%9A%84%E4%BC%98%E5%8C%96/</link>
      <pubDate>Thu, 23 Jan 2020 21:56:44 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/23/netty-%E5%AF%B9%E4%BA%8E-selector-%E7%9A%84-keyset-%E7%9A%84%E4%BC%98%E5%8C%96/</guid>
      <description>在使用 Jdk Nio 的时候，一般我们可能就直接使用 SelectorProvider.provider().openSelector() 来获取一个 Selector 便直接开始使用了，但是，netty 对于 Selector 竟然也有优化操作。 Selector 默认的 KeySet 的实现方式是 Has</description>
    </item>
    
    <item>
      <title>Netty 如何解决 JDK 空轮训的 BUG</title>
      <link>https://zhixiangyuan.github.io/2020/01/23/netty-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-jdk-%E7%A9%BA%E8%BD%AE%E8%AE%AD%E7%9A%84-bug/</link>
      <pubDate>Thu, 23 Jan 2020 21:21:31 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/23/netty-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-jdk-%E7%A9%BA%E8%BD%AE%E8%AE%AD%E7%9A%84-bug/</guid>
      <description>Netty 解决空轮训的 bug 的方式很简单，通过执行阻塞 select 的方式阻塞一段时间，如果在执行完毕之后阻塞的时间小于设定的阻塞的时间，那么 selectCnt 便 +1，当达到一定次</description>
    </item>
    
    <item>
      <title>PowerOfTwoEventExecutorChooser 的优化</title>
      <link>https://zhixiangyuan.github.io/2020/01/23/poweroftwoeventexecutorchooser-%E7%9A%84%E4%BC%98%E5%8C%96/</link>
      <pubDate>Thu, 23 Jan 2020 20:01:38 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/23/poweroftwoeventexecutorchooser-%E7%9A%84%E4%BC%98%E5%8C%96/</guid>
      <description>Netty 内部在选择使用什么 EventLoop 的时候，会使用 Chooser 来进行判断，其实就是直接调用 Chooser 中的 next 方法，对于这个地方的实现有两种，一种是 GenericEventExecutorChooser 的实现方式，也是常用的想法</description>
    </item>
    
    <item>
      <title>判断是否是 2 的幂次的方法</title>
      <link>https://zhixiangyuan.github.io/2020/01/23/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF-2-%E7%9A%84%E5%B9%82%E6%AC%A1%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 23 Jan 2020 02:26:37 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/23/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF-2-%E7%9A%84%E5%B9%82%E6%AC%A1%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>该方法来自 Netty 源码 1 2 3 4 5 6 7 /** * @param val 需要被判断是否是 2 的幂次的数 * @return true 是 2 的幂次 / false 不是 2 的幂次 */ public static boolean isPowerOfTwo(int val) { return (val &amp;amp; -val) == val; }</description>
    </item>
    
    <item>
      <title>Reactor 模式</title>
      <link>https://zhixiangyuan.github.io/2020/01/21/reactor-%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 21 Jan 2020 21:37:10 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/21/reactor-%E6%A8%A1%E5%BC%8F/</guid>
      <description>网上关于 Reactor 的文章很多，不过全是和 NIO 直接相关，本文只阐述 Reactor 设计的思想，同时给出范例代码实现。 Reactor 的设计思想是通过 Reactor 去感知到不同的事件，然后根据不</description>
    </item>
    
    <item>
      <title>Java NIO 的使用样例</title>
      <link>https://zhixiangyuan.github.io/2020/01/21/java-nio-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B/</link>
      <pubDate>Tue, 21 Jan 2020 19:28:09 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/21/java-nio-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B/</guid>
      <description>总共两个部分，一个是 NIOServer，另一个是 NIOClient。Java 的 NIO 使用起来很复杂，推荐通过 Netty 框架来使用 Java 的 NIO。 1 NIOServer 1 2 3 4</description>
    </item>
    
    <item>
      <title>Java 阻塞 IO 的使用样例</title>
      <link>https://zhixiangyuan.github.io/2020/01/21/java-%E9%98%BB%E5%A1%9E-io-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B/</link>
      <pubDate>Tue, 21 Jan 2020 19:16:57 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/21/java-%E9%98%BB%E5%A1%9E-io-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B/</guid>
      <description>样例代码分为两个部分，一个是 server，另一个是 client 这种模式的 IO 编程模型在客户端较少的情况下运行良好，但是对于客户端比较多的业务来说，单机服</description>
    </item>
    
    <item>
      <title>三种一致性模型</title>
      <link>https://zhixiangyuan.github.io/2020/01/21/%E4%B8%89%E7%A7%8D%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Tue, 21 Jan 2020 15:57:41 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/21/%E4%B8%89%E7%A7%8D%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/</guid>
      <description>1 弱一致性 当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来。比如：某些 cache 系统，网络游戏其它玩家的数据和你没什么关系，VOIP</description>
    </item>
    
    <item>
      <title>SQL 优化小记</title>
      <link>https://zhixiangyuan.github.io/2020/01/19/sql-%E4%BC%98%E5%8C%96%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Sun, 19 Jan 2020 17:02:13 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/19/sql-%E4%BC%98%E5%8C%96%E5%B0%8F%E8%AE%B0/</guid>
      <description>本篇文章使用的建表语句以及其创建数据的语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 DROP TABLE IF EXISTS employees; CREATE TABLE `employees` ( `id` INT ( 11 ) NOT NULL AUTO_INCREMENT, `name` VARCHAR ( 24 ) NOT NULL DEFAULT &amp;#39;&amp;#39; COMMENT &amp;#39</description>
    </item>
    
    <item>
      <title>Explain 小记</title>
      <link>https://zhixiangyuan.github.io/2020/01/18/explain-%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Sat, 18 Jan 2020 16:44:45 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/18/explain-%E5%B0%8F%E8%AE%B0/</guid>
      <description>explain 工具的作用是用于返回 sql 的执行计划，帮助开发人员优化 sql。 以下是本文使用的数据表的建表语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24</description>
    </item>
    
    <item>
      <title>事务的 ACDI 特性</title>
      <link>https://zhixiangyuan.github.io/2020/01/17/%E4%BA%8B%E5%8A%A1%E7%9A%84-acdi-%E7%89%B9%E6%80%A7/</link>
      <pubDate>Fri, 17 Jan 2020 09:33:42 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/17/%E4%BA%8B%E5%8A%A1%E7%9A%84-acdi-%E7%89%B9%E6%80%A7/</guid>
      <description>ACDI 分别是：原子性 (atomicity)，一致性 (consistency)，隔离性 (isolation)，持久性 (durability)。 原子</description>
    </item>
    
    <item>
      <title>InnoDB 支持的索引分类</title>
      <link>https://zhixiangyuan.github.io/2020/01/17/innodb-%E6%94%AF%E6%8C%81%E7%9A%84%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB/</link>
      <pubDate>Fri, 17 Jan 2020 00:58:44 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/17/innodb-%E6%94%AF%E6%8C%81%E7%9A%84%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB/</guid>
      <description>1 从数据结构角度看 1.1 B+Tree 索引 B+Tree 的特点便是以树的形式组织数据，同时将所有数据均放到叶子结点，最后在叶子结点上构造有序链表，这种结构使得查询数据和</description>
    </item>
    
    <item>
      <title>如何在 MySQL 中快速生成一张亿级数据量的表</title>
      <link>https://zhixiangyuan.github.io/2020/01/16/%E5%A6%82%E4%BD%95%E5%9C%A8-mysql-%E4%B8%AD%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E4%B8%80%E5%BC%A0%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E8%A1%A8/</link>
      <pubDate>Thu, 16 Jan 2020 09:08:28 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/16/%E5%A6%82%E4%BD%95%E5%9C%A8-mysql-%E4%B8%AD%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E4%B8%80%E5%BC%A0%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E8%A1%A8/</guid>
      <description>本文使用的测试硬件是树莓派4B 4G 版本 在网上找了一下，发现有两种方法，一种是弄一张内存表，用存储过程 向内存表中插入数据，然后再将数据写回数据表</description>
    </item>
    
    <item>
      <title>使用 JDBC 连接数据库的样例代码</title>
      <link>https://zhixiangyuan.github.io/2020/01/15/%E4%BD%BF%E7%94%A8-jdbc-%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%A0%B7%E4%BE%8B%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Wed, 15 Jan 2020 20:00:34 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/15/%E4%BD%BF%E7%94%A8-jdbc-%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%A0%B7%E4%BE%8B%E4%BB%A3%E7%A0%81/</guid>
      <description>1 pom 中引入依赖 1 2 3 4 5 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 2 样例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Main { static final String DB_URL = &amp;#34;jdbc:mysql://localhost:3306/test&amp;#34;; static final String USER = &amp;#34;root&amp;#34;; static final String PASS = &amp;#34;123456&amp;#34;; public static void main(String[] args) { try</description>
    </item>
    
    <item>
      <title>聊一聊范型擦除机制</title>
      <link>https://zhixiangyuan.github.io/2020/01/15/%E8%81%8A%E4%B8%80%E8%81%8A%E8%8C%83%E5%9E%8B%E6%93%A6%E9%99%A4%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Wed, 15 Jan 2020 17:47:36 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/15/%E8%81%8A%E4%B8%80%E8%81%8A%E8%8C%83%E5%9E%8B%E6%93%A6%E9%99%A4%E6%9C%BA%E5%88%B6/</guid>
      <description>注意：本文中使用 ResolvableType 是 Spring framework 中提供的工具类，用于简化获取类的信息，该类位于 spring-core 项目下，想使用的小伙伴引入 spring-core 项目即可使用。 似乎，从学习 java 的范型开始，</description>
    </item>
    
    <item>
      <title>树莓派小记</title>
      <link>https://zhixiangyuan.github.io/2020/01/15/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Wed, 15 Jan 2020 13:56:15 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/15/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B0%8F%E8%AE%B0/</guid>
      <description>1 默认树莓派账号密码 账号：pi 密码：raspberry 注意：root 账户登陆进 pi 后使用 sudo passwd root 进行设置 2 如何系统在写入 SD 卡后配置 WIFI 在 SD 卡根目录</description>
    </item>
    
    <item>
      <title>转载：HTTPS 原理</title>
      <link>https://zhixiangyuan.github.io/2020/01/14/%E8%BD%AC%E8%BD%BDhttps-%E5%8E%9F%E7%90%86/</link>
      <pubDate>Tue, 14 Jan 2020 18:29:21 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/14/%E8%BD%AC%E8%BD%BDhttps-%E5%8E%9F%E7%90%86/</guid>
      <description>本文转载自：（多图）老弟，你连HTTPS 原理都不懂，还给我讲“中间人攻击”，逗我吗&amp;hellip; 1 HTTPS 随着 HTTPS 建站的成本下降，现在大部分的网站</description>
    </item>
    
    <item>
      <title>查看 mysql 表相关信息</title>
      <link>https://zhixiangyuan.github.io/2020/01/13/%E6%9F%A5%E7%9C%8B-mysql-%E8%A1%A8%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Mon, 13 Jan 2020 15:30:42 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/13/%E6%9F%A5%E7%9C%8B-mysql-%E8%A1%A8%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 -- \G 表示的意思是数据以列的方式显示 -- 需要注意的是在 navicat 的命令行里面这样用会报错 -- 通过以下语句查看表的相关信息 -- 查看所有表的</description>
    </item>
    
    <item>
      <title>为 Spring Bean 指定初始化和销毁方法的几种方式</title>
      <link>https://zhixiangyuan.github.io/2020/01/13/%E4%B8%BA-spring-bean-%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 13 Jan 2020 08:25:29 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/13/%E4%B8%BA-spring-bean-%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
      <description>1 Xml 方式指定 假设我们先创建下面这个 Bean 1 2 3 4 5 6 7 8 9 10 11 12 13 public class CoffeeBean { public CoffeeBean() { System.out.println(&amp;#34;Construct bean.&amp;#34;); } public void init() { System.out.println(&amp;#34;Bean init.&amp;#34;); } public void destroy() { System.out.println(&amp;#34;Bean destroy.&amp;#34;); } } 1 2 &amp;lt;bean id=&amp;#34;coffee&amp;#34; class=&amp;#34;me.yuanzx.test.CoffeeBean&amp;#34; init-method=&amp;#34;init&amp;#34; destroy-method=&amp;#34;destory&amp;#34;&amp;gt; &amp;lt;/bean&amp;gt; 2 在 @Bean 的时候</description>
    </item>
    
    <item>
      <title>Maven 中的各种 Scope 的含义</title>
      <link>https://zhixiangyuan.github.io/2020/01/12/maven-%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D-scope-%E7%9A%84%E5%90%AB%E4%B9%89/</link>
      <pubDate>Sun, 12 Jan 2020 16:09:56 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/12/maven-%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D-scope-%E7%9A%84%E5%90%AB%E4%B9%89/</guid>
      <description>Scope 总共有六种分别是 compile、provided、runtime、test、system、import，下面便分别来阐述每种 Scope 的作用。 1 compile</description>
    </item>
    
    <item>
      <title>lombok 中生成构造方法的注解</title>
      <link>https://zhixiangyuan.github.io/2020/01/06/lombok-%E4%B8%AD%E7%94%9F%E6%88%90%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Mon, 06 Jan 2020 19:50:07 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/06/lombok-%E4%B8%AD%E7%94%9F%E6%88%90%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E8%A7%A3/</guid>
      <description>本文基于 org.projectlombok.lombok:1.18.10 这样的注解总共有三个，分别是 @NoArgsConstructor、@RequiredArgsConstructor 和 @AllArg</description>
    </item>
    
    <item>
      <title>class 文件的字节码结构</title>
      <link>https://zhixiangyuan.github.io/2020/01/04/class-%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sat, 04 Jan 2020 11:41:22 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/04/class-%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84/</guid>
      <description>1 结构预览 1.1 数据结构对照表 数据结构含义对照表，该数据结构将在下文中使用 数据结构 含义 u1 1 个字节的无符号数 u2 2 个字节的无符号数 u4 4 个字节的无符号</description>
    </item>
    
    <item>
      <title>java 的 spi 机制</title>
      <link>https://zhixiangyuan.github.io/2020/01/03/java-%E7%9A%84-spi-%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Fri, 03 Jan 2020 11:12:16 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/03/java-%E7%9A%84-spi-%E6%9C%BA%E5%88%B6/</guid>
      <description>java 的 spi 机制简单来说就是通过 com.sun.tools.javac.util.ServiceLoader 加载整个 classpath 下的 META-INF/services 目录下的文件以实现加载指定类的功能，这样实现的好处是可以做到动态插拔依赖实现自动配置的效果。 下面</description>
    </item>
    
    <item>
      <title>聊一聊 SpringApplicationRunListener 调用的时机</title>
      <link>https://zhixiangyuan.github.io/2019/12/30/%E8%81%8A%E4%B8%80%E8%81%8A-springapplicationrunlistener-%E8%B0%83%E7%94%A8%E7%9A%84%E6%97%B6%E6%9C%BA/</link>
      <pubDate>Mon, 30 Dec 2019 11:09:37 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/30/%E8%81%8A%E4%B8%80%E8%81%8A-springapplicationrunlistener-%E8%B0%83%E7%94%A8%E7%9A%84%E6%97%B6%E6%9C%BA/</guid>
      <description>SpringApplicationRunListener 是 SpringBoot 中的一个接口，这个接口中的方法会在 SpringBoot 应用的生命周期中不同时间进行调用。下面看一看这个接口中的相关方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17</description>
    </item>
    
    <item>
      <title>设置 SprintBoot 的 spring.profiles.active 的几种方式</title>
      <link>https://zhixiangyuan.github.io/2019/12/30/%E8%AE%BE%E7%BD%AE-sprintboot-%E7%9A%84-spring.profiles.active-%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 30 Dec 2019 08:01:36 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/30/%E8%AE%BE%E7%BD%AE-sprintboot-%E7%9A%84-spring.profiles.active-%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
      <description>1 在配置文件中指定 在 application.xml 中指定 1 2 3 spring:profiles:active:dev 2 在 maven 中指定 在配置文件中使用占位符指定 1 2 3 spring:profiles:active:@package.target@ 在 pom.xml 中以 profile 的形式指定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19</description>
    </item>
    
    <item>
      <title>正则表达式必知必会笔记</title>
      <link>https://zhixiangyuan.github.io/2019/12/24/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 24 Dec 2019 08:30:48 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/24/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%AC%94%E8%AE%B0/</guid>
      <description>1 第一章 正则表达式入门 正则表达式是一些用来匹配和处理文本的字符串 提示：同样的问题几乎总是有好几种不同的解决办法，这些办法并无优劣之分，你尽可</description>
    </item>
    
    <item>
      <title>Spring Aop 中 AspectJProxyFactory 的使用方式</title>
      <link>https://zhixiangyuan.github.io/2019/12/23/spring-aop-%E4%B8%AD-aspectjproxyfactory-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 23 Dec 2019 16:57:14 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/23/spring-aop-%E4%B8%AD-aspectjproxyfactory-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /** 定义目标类 */ public class AspectTarget { public void method1() { System.out.println(&amp;#34;method1 execution&amp;#34;);</description>
    </item>
    
    <item>
      <title>Spring 中 BeanFactory 和 FactoryBean 的区别</title>
      <link>https://zhixiangyuan.github.io/2019/12/22/spring-%E4%B8%AD-beanfactory-%E5%92%8C-factorybean-%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 22 Dec 2019 16:32:19 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/22/spring-%E4%B8%AD-beanfactory-%E5%92%8C-factorybean-%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>BeanFactory 是生产 bean 的工厂 FactoryBean 是工厂的 bean</description>
    </item>
    
    <item>
      <title>动态代理模式</title>
      <link>https://zhixiangyuan.github.io/2019/12/20/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 20 Dec 2019 10:47:26 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/20/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>Java 的动态代理是基于静态代理演化而来的，所以我们先看看静态代理 1 静态代理 静态代理就是对原来对象的包装，通过实现相同的接口来达到这个效果 1 2 3 4</description>
    </item>
    
    <item>
      <title>XML 的命名空间</title>
      <link>https://zhixiangyuan.github.io/2019/12/18/xml-%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</link>
      <pubDate>Wed, 18 Dec 2019 16:02:00 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/18/xml-%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</guid>
      <description>下面的例子是一个 XML 的命名空间的例子 1 2 3 4 5 6 7 8 9 10 11 12 13 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:context=&amp;#34;http://www.springframework.org/schema/context&amp;#34; xsi:schemaLocation=&amp;#34; http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&amp;#34; &amp;gt; &amp;lt;context:annotation-config/&amp;gt; &amp;lt;/beans&amp;gt; 分析写在下面，下面为了方便用 # 作为注释符号 1 2 3 4</description>
    </item>
    
    <item>
      <title>Constructor 的 getParameterTypes 与 getGenericParameterTypes 的区别</title>
      <link>https://zhixiangyuan.github.io/2019/12/17/constructor-%E7%9A%84-getparametertypes-%E4%B8%8E-getgenericparametertypes-%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 17 Dec 2019 18:11:08 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/17/constructor-%E7%9A%84-getparametertypes-%E4%B8%8E-getgenericparametertypes-%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>getParameterTypes 与 getGenericParameterTypes 区别在于，对于没有泛型的方法参数，两者返回的均是相同的 Class，对于带泛型的方法参数 getGenericParameterTypes 返回的是带泛型的类型，getParameter</description>
    </item>
    
    <item>
      <title>Method 的 getParameterTypes 与 getGenericParameterTypes 的区别</title>
      <link>https://zhixiangyuan.github.io/2019/12/17/method-%E7%9A%84-getparametertypes-%E4%B8%8E-getgenericparametertypes-%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 17 Dec 2019 18:03:24 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/17/method-%E7%9A%84-getparametertypes-%E4%B8%8E-getgenericparametertypes-%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>getParameterTypes 与 getGenericParameterTypes 区别在于，对于没有泛型的方法参数，两者返回的均是相同的 Class，对于带泛型的方法参数 getGenericParameterTypes 返回的是带泛型的类型，getParameter</description>
    </item>
    
    <item>
      <title>Field 的 getType  与 getGenericType 的区别</title>
      <link>https://zhixiangyuan.github.io/2019/12/17/field-%E7%9A%84-gettype-%E4%B8%8E-getgenerictype-%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 17 Dec 2019 17:49:26 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/17/field-%E7%9A%84-gettype-%E4%B8%8E-getgenerictype-%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>getType 与 getGenericType 区别在于，对于没有泛型的字段类型，两者返回的均是相同的 Class，对于带泛型的字段 getGenericType 返回的是带泛型的类型，getType 返回的是不带泛</description>
    </item>
    
    <item>
      <title>Class 的 getSuperclass 与 getGenericSuperclass 区别</title>
      <link>https://zhixiangyuan.github.io/2019/12/17/class-%E7%9A%84-getsuperclass-%E4%B8%8E-getgenericsuperclass-%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 17 Dec 2019 17:29:41 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/17/class-%E7%9A%84-getsuperclass-%E4%B8%8E-getgenericsuperclass-%E5%8C%BA%E5%88%AB/</guid>
      <description>getSuperclass 与 getGenericSuperclass 如果继承的父类没有泛型，那么返回的结果是相同的，如果继承的父类包含泛型，则会返回带泛型的父类类型（sun.reflect.generi</description>
    </item>
    
    <item>
      <title>了解 JDK 中的 WildcardType 接口</title>
      <link>https://zhixiangyuan.github.io/2019/12/17/%E4%BA%86%E8%A7%A3-jdk-%E4%B8%AD%E7%9A%84-wildcardtype-%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Tue, 17 Dec 2019 16:42:34 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/17/%E4%BA%86%E8%A7%A3-jdk-%E4%B8%AD%E7%9A%84-wildcardtype-%E6%8E%A5%E5%8F%A3/</guid>
      <description>1 WildcardType 接口的继承关系 2 WildcardType 中的方法含义 1 2 3 4 5 6 7 public interface WildcardType extends Type { /** 获取泛型变量的上边界 */ Type[] getUpperBounds(); /** 获取泛型变量的下边界 */ Type[] getLowerBounds(); } 3 举个例子 1 2 3 4 5 6</description>
    </item>
    
    <item>
      <title>了解 JDK 中的 GenericArrayType 接口</title>
      <link>https://zhixiangyuan.github.io/2019/12/17/%E4%BA%86%E8%A7%A3-jdk-%E4%B8%AD%E7%9A%84-genericarraytype-%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Tue, 17 Dec 2019 16:08:41 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/17/%E4%BA%86%E8%A7%A3-jdk-%E4%B8%AD%E7%9A%84-genericarraytype-%E6%8E%A5%E5%8F%A3/</guid>
      <description>1 GenericArrayType 接口的继承关系 这个接口表示泛型类型的数组，直接这样说可能不是很清晰，看下面的讲解 2 GenericArrayType 中的方法含义 1 2 3 4 public interface GenericArrayType extends Type { /** 获得数组元素类型，</description>
    </item>
    
    <item>
      <title>了解 JDK 中的 TypeVariable 接口</title>
      <link>https://zhixiangyuan.github.io/2019/12/17/%E4%BA%86%E8%A7%A3-jdk-%E4%B8%AD%E7%9A%84-typevariable-%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Tue, 17 Dec 2019 14:29:00 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/17/%E4%BA%86%E8%A7%A3-jdk-%E4%B8%AD%E7%9A%84-typevariable-%E6%8E%A5%E5%8F%A3/</guid>
      <description>JDK 中的 TypeVariable 翻译过来就是类型变量，其实就是指泛型。 1 TypeVariable 接口的继承关系 GenericDeclaration 这个接口的含义是决定哪些地方可以定义泛型 通过上图可以看到 Class、Con</description>
    </item>
    
    <item>
      <title>了解 JDK 中的 ParameterizedType 接口</title>
      <link>https://zhixiangyuan.github.io/2019/12/17/%E4%BA%86%E8%A7%A3-jdk-%E4%B8%AD%E7%9A%84-parameterizedtype-%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Tue, 17 Dec 2019 13:08:36 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/17/%E4%BA%86%E8%A7%A3-jdk-%E4%B8%AD%E7%9A%84-parameterizedtype-%E6%8E%A5%E5%8F%A3/</guid>
      <description>1 ParameterizedType 接口的继承关系 Type 是 Java 中所有类型的通用超级接口，继承就完事了。 2 ParameterizedType 中的方法含义 1 2 3 4 5 6 7 8 9 10 11 /** 下面将 &amp;lt;&amp;gt; 中存储的内容称为泛型列表 */ public</description>
    </item>
    
    <item>
      <title>JDK 与 Spring 中的事件模型</title>
      <link>https://zhixiangyuan.github.io/2019/12/16/jdk-%E4%B8%8E-spring-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 16 Dec 2019 16:55:27 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/16/jdk-%E4%B8%8E-spring-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/</guid>
      <description>1 事件模型 JDK 中提供了一个接口和一个类给用户实现自己的事件机制，一个是 EventObject 事件，另一个是 EventListener 事件监听器。 一般使用是都是在事件监听器中实现相应的方法</description>
    </item>
    
    <item>
      <title>spring 中的 Resource 和 ResourceLoader</title>
      <link>https://zhixiangyuan.github.io/2019/12/16/spring-%E4%B8%AD%E7%9A%84-resource-%E5%92%8C-resourceloader/</link>
      <pubDate>Mon, 16 Dec 2019 10:00:29 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/16/spring-%E4%B8%AD%E7%9A%84-resource-%E5%92%8C-resourceloader/</guid>
      <description>1 Resource 由于 Java 定义的 java.net.URL（Uniform Resource Locator）统一资源定位器有些狭隘，无法做到统一定位资源的作用（todo 这里有</description>
    </item>
    
    <item>
      <title>Spring Xml 配置文件格式</title>
      <link>https://zhixiangyuan.github.io/2019/12/13/spring-xml-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Fri, 13 Dec 2019 13:23:09 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/13/spring-xml-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70</description>
    </item>
    
    <item>
      <title>语义化版本控制</title>
      <link>https://zhixiangyuan.github.io/2019/12/13/%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Fri, 13 Dec 2019 10:49:49 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/13/%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</guid>
      <description>语义化的版本号遵循这个格式：MAJOR.MINOR.PATCH。其中 MAJOR 的改变意味着其中包含向后不兼容的修改，MINOR 的改变意味着有新功能的</description>
    </item>
    
    <item>
      <title>JDK8 中新增的 TYPE_USE 和 TYPE_PARAMETER 可以用在什么场景</title>
      <link>https://zhixiangyuan.github.io/2019/12/12/jdk8-%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84-type_use-%E5%92%8C-type_parameter-%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Thu, 12 Dec 2019 13:48:56 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/12/jdk8-%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84-type_use-%E5%92%8C-type_parameter-%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF/</guid>
      <description>本篇直接用示例代码展示该注解可以用在什么场景 1 TYPE_USE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 先定义一个测试注解</description>
    </item>
    
    <item>
      <title>Java 的可重入锁可以重入多少次</title>
      <link>https://zhixiangyuan.github.io/2019/12/10/java-%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%85%A5%E5%A4%9A%E5%B0%91%E6%AC%A1/</link>
      <pubDate>Tue, 10 Dec 2019 15:01:38 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/10/java-%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%85%A5%E5%A4%9A%E5%B0%91%E6%AC%A1/</guid>
      <description>Java 中有两个常用的可重入锁，一个是 synchronized，另一个是 ReentrantLock，我们先测试 ReentrantLock 的可重入次数 1 ReentrantLock 的可重入次数上限 1</description>
    </item>
    
    <item>
      <title>IDEA 中 UML 的箭头含义</title>
      <link>https://zhixiangyuan.github.io/2019/12/10/idea-%E4%B8%AD-uml-%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%90%AB%E4%B9%89/</link>
      <pubDate>Tue, 10 Dec 2019 08:28:37 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/10/idea-%E4%B8%AD-uml-%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%90%AB%E4%B9%89/</guid>
      <description>本文中所使用的关系名词并不是 UML 中所定义的，因为我觉得他那种方式不够具体，对于 Javer 来说并不好理解，所以这里我直接用易于 javer 理解的名词来解释类之间的</description>
    </item>
    
    <item>
      <title>自旋锁 与 适应性自旋锁</title>
      <link>https://zhixiangyuan.github.io/2019/12/09/%E8%87%AA%E6%97%8B%E9%94%81-%E4%B8%8E-%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B%E9%94%81/</link>
      <pubDate>Mon, 09 Dec 2019 20:30:38 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/09/%E8%87%AA%E6%97%8B%E9%94%81-%E4%B8%8E-%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B%E9%94%81/</guid>
      <description>阻塞或唤醒一个 Java 线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间，如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比</description>
    </item>
    
    <item>
      <title>谈谈 CAS</title>
      <link>https://zhixiangyuan.github.io/2019/12/09/%E8%B0%88%E8%B0%88-cas/</link>
      <pubDate>Mon, 09 Dec 2019 15:04:35 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/09/%E8%B0%88%E8%B0%88-cas/</guid>
      <description>CAS 其实指的就是 sun.misc.Unsafe 类中的一系列 compareAndSwap 方法 例如 compareAndSwapInt 方法 1 2 3 public final native boolean compareAndSwapInt( Object o, long offset, int expected, int x ); 这种方法提供四个参数，分别是需要修改值的对象 o，需要改的值在对</description>
    </item>
    
    <item>
      <title>乐观锁 与 悲观锁</title>
      <link>https://zhixiangyuan.github.io/2019/12/09/%E4%B9%90%E8%A7%82%E9%94%81-%E4%B8%8E-%E6%82%B2%E8%A7%82%E9%94%81/</link>
      <pubDate>Mon, 09 Dec 2019 14:25:48 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/09/%E4%B9%90%E8%A7%82%E9%94%81-%E4%B8%8E-%E6%82%B2%E8%A7%82%E9%94%81/</guid>
      <description>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度，在 Java 和数据库中都有此概念对应的实际应用。 1 概念 悲观锁的概念：悲观锁认为自己在</description>
    </item>
    
    <item>
      <title>深度跟踪 Class 的 public InputStream getResourceAsStream(String name) 方法</title>
      <link>https://zhixiangyuan.github.io/2019/12/07/%E6%B7%B1%E5%BA%A6%E8%B7%9F%E8%B8%AA-class-%E7%9A%84-public-inputstream-getresourceasstreamstring-name-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 07 Dec 2019 06:31:41 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/07/%E6%B7%B1%E5%BA%A6%E8%B7%9F%E8%B8%AA-class-%E7%9A%84-public-inputstream-getresourceasstreamstring-name-%E6%96%B9%E6%B3%95/</guid>
      <description>本日志基于 openjdk8 1 public final class Class 我们从这个方法开始 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public InputStream getResourceAsStream(String name) { // 这个方法见 1.1 解析 // 这里假如传入的 name 为 /Web.xml</description>
    </item>
    
    <item>
      <title>大小写字母转换技巧</title>
      <link>https://zhixiangyuan.github.io/2019/12/05/%E5%A4%A7%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E8%BD%AC%E6%8D%A2%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Thu, 05 Dec 2019 10:46:36 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/05/%E5%A4%A7%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E8%BD%AC%E6%8D%A2%E6%8A%80%E5%B7%A7/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * 小写转大写 * * @param c 小写字母 * @return 大写字母 */ public static char upper(char c) { return (char) (c &amp;amp; 0xdf); } /** * 大写转小写 * * @param</description>
    </item>
    
    <item>
      <title>如何查看文本文件的编码格式</title>
      <link>https://zhixiangyuan.github.io/2019/12/04/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Wed, 04 Dec 2019 14:14:09 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/04/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/</guid>
      <description>通过查看文本文件的前两个字节就可以知道该文件是什么编码 1 2 3 4 前两个字节 编码格式 0xFFFE Unicode 0xFEFF Unicode big endian 0xEFBB UTF-8</description>
    </item>
    
    <item>
      <title>FutureTask 的取消功能是怎么实现的</title>
      <link>https://zhixiangyuan.github.io/2019/12/03/futuretask-%E7%9A%84%E5%8F%96%E6%B6%88%E5%8A%9F%E8%83%BD%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/</link>
      <pubDate>Tue, 03 Dec 2019 20:19:16 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/03/futuretask-%E7%9A%84%E5%8F%96%E6%B6%88%E5%8A%9F%E8%83%BD%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/</guid>
      <description>本文基于 jdk 1.8 直接看取消的函数实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt; { ... public boolean cancel(boolean mayInterruptIfRunning) { if (!(state == NEW &amp;amp;&amp;amp; UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) return false; try {</description>
    </item>
    
    <item>
      <title>Java 中的 WeakReference 和 SoftReference</title>
      <link>https://zhixiangyuan.github.io/2019/11/28/java-%E4%B8%AD%E7%9A%84-weakreference-%E5%92%8C-softreference/</link>
      <pubDate>Thu, 28 Nov 2019 16:48:50 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/28/java-%E4%B8%AD%E7%9A%84-weakreference-%E5%92%8C-softreference/</guid>
      <description>1 WeakReference 当一个对象没有被强引用时，只有 WeakReference，那么在下一次 GC 时会被回收。 1 2 3 4 5 6 7 8 9 10 public static void main(String[] args) { Object referent = new Object(); WeakReference&amp;lt;Object&amp;gt; weakReference = new WeakReference&amp;lt;&amp;gt;(referent);</description>
    </item>
    
    <item>
      <title>ScheduledThreadPoolExecutor 的实现原理</title>
      <link>https://zhixiangyuan.github.io/2019/11/28/scheduledthreadpoolexecutor-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 28 Nov 2019 14:54:19 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/28/scheduledthreadpoolexecutor-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>1 如何实现定时的效果 定时效果实现的关键在 ScheduledFutureTask 的 public void run() 方法，下面是该方法的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public void run() { // 判断是否是</description>
    </item>
    
    <item>
      <title>WeakReference 的使用场景</title>
      <link>https://zhixiangyuan.github.io/2019/11/26/weakreference-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Tue, 26 Nov 2019 11:33:07 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/26/weakreference-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</guid>
      <description>WeakReference 所指的便是弱引用，它的作用便是能够让你获取到引用到对象，但是当弱引用引用的对象没有强引用引用时，那么便可以被虚拟机回收。这个类可以用在下面</description>
    </item>
    
    <item>
      <title>蓝绿发布、AB 测试和灰度发布</title>
      <link>https://zhixiangyuan.github.io/2019/11/25/%E8%93%9D%E7%BB%BF%E5%8F%91%E5%B8%83ab-%E6%B5%8B%E8%AF%95%E5%92%8C%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/</link>
      <pubDate>Mon, 25 Nov 2019 15:16:41 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/25/%E8%93%9D%E7%BB%BF%E5%8F%91%E5%B8%83ab-%E6%B5%8B%E8%AF%95%E5%92%8C%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/</guid>
      <description>1 蓝绿发布 蓝绿发布可以减少发布过程中服务停止的时间，但是带来了另一个问题，就是需要的机器数量需要翻倍。发布时候，首先流量都是打在绿色的版本上</description>
    </item>
    
    <item>
      <title>TCP 中的七个定时器</title>
      <link>https://zhixiangyuan.github.io/2019/11/25/tcp-%E4%B8%AD%E7%9A%84%E4%B8%83%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/</link>
      <pubDate>Mon, 25 Nov 2019 11:39:43 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/25/tcp-%E4%B8%AD%E7%9A%84%E4%B8%83%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/</guid>
      <description>1 连接建立定时器 这个定时器的作用就是在建立连接发送第一个 SYN 包的时候起作用，在发送 SYN 包后开启这个定时器，如果定的时间到了，那么就会重传 SYN 数据包</description>
    </item>
    
    <item>
      <title>删除数据库时报错的解决方案</title>
      <link>https://zhixiangyuan.github.io/2019/11/24/%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%B6%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Sun, 24 Nov 2019 13:01:39 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/24/%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%B6%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>今天删除数据库的时候出现了一个诡异的报错，报错如下所示 1 1010 - Error dropping database (can&amp;#39;t rmdir &amp;#39;./apolloportaldb&amp;#39;, errno: 39) 网上查了一下，解决方案是直接去手动删除文件夹中的内容，我是 docker 启动</description>
    </item>
    
    <item>
      <title>如何关闭 Logback 的初始化日志</title>
      <link>https://zhixiangyuan.github.io/2019/11/22/%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD-logback-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%A5%E5%BF%97/</link>
      <pubDate>Fri, 22 Nov 2019 10:22:25 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/22/%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD-logback-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%A5%E5%BF%97/</guid>
      <description>logback 版本 1.1.1 先看解决方案 1 2 3 4 5 6 7 8 9 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;configuration&amp;gt; ... &amp;lt;!-- 关闭 logback 自身的初始化日志 --&amp;gt; &amp;lt;!-- 使用 NopStatusListener 或 StatusListenerAsList 均可以达到效果--&amp;gt; &amp;lt;!-- &amp;lt;statusListener class=&amp;#34;ch.qos.logback.core.status.NopStatusListener&amp;#34;/&amp;gt;--&amp;gt; &amp;lt;statusListener class=&amp;#34;ch.qos.logback.core.status.StatusListenerAsList&amp;#34;/&amp;gt; ... &amp;lt;/configuration&amp;gt; 1 为什么加上一</description>
    </item>
    
    <item>
      <title>TCP 中的 SO_LINGER 选项</title>
      <link>https://zhixiangyuan.github.io/2019/11/19/tcp-%E4%B8%AD%E7%9A%84-so_linger-%E9%80%89%E9%A1%B9/</link>
      <pubDate>Tue, 19 Nov 2019 21:04:04 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/19/tcp-%E4%B8%AD%E7%9A%84-so_linger-%E9%80%89%E9%A1%B9/</guid>
      <description>SO_LINGER 参数的作用就是改变 close 的默认行为，SO_LINGER 参数在 Linux 系统中就是一个 linger 结构体，代码如下 1 2 3 4 struct linger { int l_onoff; /* linger active */ int l_linger; /* how many seconds to linger for */ };</description>
    </item>
    
    <item>
      <title>TCP 中的 SO_REUSEADDR 选项</title>
      <link>https://zhixiangyuan.github.io/2019/11/19/tcp-%E4%B8%AD%E7%9A%84-so_reuseaddr-%E9%80%89%E9%A1%B9/</link>
      <pubDate>Tue, 19 Nov 2019 19:57:55 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/19/tcp-%E4%B8%AD%E7%9A%84-so_reuseaddr-%E9%80%89%E9%A1%B9/</guid>
      <description>1 地址重用 SO_REUSEADDR 选项的作用就像它的名字一样，它是用来使得地址能够重用的。比如说我的 ip 是 192.168.3.9，那么如果没有设置这个选项，那么当我</description>
    </item>
    
    <item>
      <title>关于 TCP 半连接队列与全连接队列</title>
      <link>https://zhixiangyuan.github.io/2019/11/18/%E5%85%B3%E4%BA%8E-tcp-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E4%B8%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/</link>
      <pubDate>Mon, 18 Nov 2019 14:51:35 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/18/%E5%85%B3%E4%BA%8E-tcp-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E4%B8%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/</guid>
      <description>以下使用 client 代替客户端，server 代替服务端，看起来更清晰 半连接队列与全连接队列与服务端相关，在 server 调用 int listen(int sockfd, int backlog); 开启 LISTEN 监听时，与此同时内核创</description>
    </item>
    
    <item>
      <title>Shell 中的 ``、$()、${} 和 $(())</title>
      <link>https://zhixiangyuan.github.io/2019/11/17/shell-%E4%B8%AD%E7%9A%84-%E5%92%8C/</link>
      <pubDate>Sun, 17 Nov 2019 21:30:01 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/17/shell-%E4%B8%AD%E7%9A%84-%E5%92%8C/</guid>
      <description>1 ${} 这个符号用于变量替换 2 `` 和 $() 这两个都用于命令替换，意思就是他们两个里面写的东西会当成命令执行。 `` 所有的系统都支持，$() 可能会有系统不支</description>
    </item>
    
    <item>
      <title>TCP 11 种状态变迁</title>
      <link>https://zhixiangyuan.github.io/2019/11/17/tcp-11-%E7%A7%8D%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81/</link>
      <pubDate>Sun, 17 Nov 2019 15:56:38 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/17/tcp-11-%E7%A7%8D%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81/</guid>
      <description>1 CLOSED CLOSED 状态是一个假想的状态，它处于 TCP 连接还未开始建立或者已经释放掉的状态。因此无法通过 netstat 或者 lsof 看到。 从 CLOSED 状态转换为其他状态有两种可能 一种是服</description>
    </item>
    
    <item>
      <title>TCP 三次握手详解</title>
      <link>https://zhixiangyuan.github.io/2019/11/17/tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 17 Nov 2019 14:40:12 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/17/tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%AF%A6%E8%A7%A3/</guid>
      <description>1 三次握手数据包交互过程 下面用 client 表述客户端，server 表述服务端，这样看起来更清晰。 client 发出 SYN 数据包给服务端，同时初始化一个序列号 X，发出数</description>
    </item>
    
    <item>
      <title>TCP 四次挥手详解</title>
      <link>https://zhixiangyuan.github.io/2019/11/17/tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 17 Nov 2019 11:00:11 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/17/tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/</guid>
      <description>1 四次挥手数据包的交互过程 下面用 client 表述客户端，server 表述服务端，这样看起来更清晰。 client 发送 FIN 包给 server，发送后 client 进入 FIN-WAIT-1 状态 server 收到 client</description>
    </item>
    
    <item>
      <title>如何在 Maven 打包的时候设置主类</title>
      <link>https://zhixiangyuan.github.io/2019/11/16/%E5%A6%82%E4%BD%95%E5%9C%A8-maven-%E6%89%93%E5%8C%85%E7%9A%84%E6%97%B6%E5%80%99%E8%AE%BE%E7%BD%AE%E4%B8%BB%E7%B1%BB/</link>
      <pubDate>Sat, 16 Nov 2019 22:02:48 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/16/%E5%A6%82%E4%BD%95%E5%9C%A8-maven-%E6%89%93%E5%8C%85%E7%9A%84%E6%97%B6%E5%80%99%E8%AE%BE%E7%BD%AE%E4%B8%BB%E7%B1%BB/</guid>
      <description>1 普通项目 在 maven 中配置以下插件即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; ... &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-jar-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.4&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;archive&amp;gt; &amp;lt;manifest&amp;gt; &amp;lt;addClasspath&amp;gt;true&amp;lt;/addClasspath&amp;gt; &amp;lt;classpathPrefix&amp;gt;lib/&amp;lt;/classpathPrefix&amp;gt; &amp;lt;mainClass&amp;gt;&amp;lt;$mainClass&amp;gt;&amp;lt;/mainClass&amp;gt; &amp;lt;/manifest&amp;gt; &amp;lt;/archive&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; 原理便是在打包的时候，向 MANIFEST.MF 文件中</description>
    </item>
    
    <item>
      <title>解决 OBS 无法录制 Soundflower 的问题</title>
      <link>https://zhixiangyuan.github.io/2019/11/16/%E8%A7%A3%E5%86%B3-obs-%E6%97%A0%E6%B3%95%E5%BD%95%E5%88%B6-soundflower-%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 16 Nov 2019 09:45:12 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/16/%E8%A7%A3%E5%86%B3-obs-%E6%97%A0%E6%B3%95%E5%BD%95%E5%88%B6-soundflower-%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>本文中使用的 OBS 为 24.0.2 版本，这个版本在最新的 catalina 有 bug，它不会自动申请麦克风权限，我又没办法把权限给他，就造成了没法录声音的问题，解决办法是通过</description>
    </item>
    
    <item>
      <title>在 Mac 上获取 Gopro Udp 视频流</title>
      <link>https://zhixiangyuan.github.io/2019/11/16/%E5%9C%A8-mac-%E4%B8%8A%E8%8E%B7%E5%8F%96-gopro-udp-%E8%A7%86%E9%A2%91%E6%B5%81/</link>
      <pubDate>Sat, 16 Nov 2019 09:34:37 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/16/%E5%9C%A8-mac-%E4%B8%8A%E8%8E%B7%E5%8F%96-gopro-udp-%E8%A7%86%E9%A2%91%E6%B5%81/</guid>
      <description>gopro 可以直接通过 wifi 传送 udp 视频流，本文讲解如何从其中获取 udp 视频流并在 mac 上播放。 本文使用 gopro 4 black 进行测试，如果使用其他型号的 gopro，触发 url 参考 https://github.com/KonradIT/goprowifihack</description>
    </item>
    
    <item>
      <title>Google 的程序员等级精简说明</title>
      <link>https://zhixiangyuan.github.io/2019/11/15/google-%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E7%AD%89%E7%BA%A7%E7%B2%BE%E7%AE%80%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Fri, 15 Nov 2019 09:50:41 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/15/google-%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E7%AD%89%E7%BA%A7%E7%B2%BE%E7%AE%80%E8%AF%B4%E6%98%8E/</guid>
      <description>可以简单参考下Google的程序员等级说明. 具体很长,我高度简化(略带修饰)的总结下: 1 Software Engineer I 技术方面: 你需要培养一阵才能真正有用.这个级别</description>
    </item>
    
    <item>
      <title>构造一个处于 SYN_SENT 状态的连接</title>
      <link>https://zhixiangyuan.github.io/2019/11/14/%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E5%A4%84%E4%BA%8E-syn_sent-%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Thu, 14 Nov 2019 21:29:27 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/14/%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E5%A4%84%E4%BA%8E-syn_sent-%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%9E%E6%8E%A5/</guid>
      <description>下图是一个三次握手的变化过程 在客户端发出 SYN 包之后，便进入 SYN-SENT 的状态，如果没有收到服务端的 ACK，那么便会一直维持在这个状态，多次重发 SYN 数据包，</description>
    </item>
    
    <item>
      <title>tcpdump 小记</title>
      <link>https://zhixiangyuan.github.io/2019/11/14/tcpdump-%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Thu, 14 Nov 2019 09:39:39 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/14/tcpdump-%E5%B0%8F%E8%AE%B0/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70</description>
    </item>
    
    <item>
      <title>通过文件描述符查找进程监听的端口号</title>
      <link>https://zhixiangyuan.github.io/2019/11/13/%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%9F%A5%E6%89%BE%E8%BF%9B%E7%A8%8B%E7%9B%91%E5%90%AC%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7/</link>
      <pubDate>Wed, 13 Nov 2019 22:07:32 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/13/%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%9F%A5%E6%89%BE%E8%BF%9B%E7%A8%8B%E7%9B%91%E5%90%AC%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 # 首先，我们通过开启监听</description>
    </item>
    
    <item>
      <title>lsof 小记</title>
      <link>https://zhixiangyuan.github.io/2019/11/13/lsof-%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Wed, 13 Nov 2019 21:32:47 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/13/lsof-%E5%B0%8F%E8%AE%B0/</guid>
      <description>1 2 3 4 5 6 7 # 查看端口被什么进程占用 # -n 表示不将 IP 转换为 hostname # -P 表示不将 port number 转换为 service name $&amp;gt; lsof -n -P -i:&amp;lt;$port&amp;gt; # 查看进程监听了哪些端口号 $&amp;gt; lsof -n -P -p &amp;lt;$pid&amp;gt; | grep TCP</description>
    </item>
    
    <item>
      <title>javap 命令小记</title>
      <link>https://zhixiangyuan.github.io/2019/11/13/javap-%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Wed, 13 Nov 2019 17:00:53 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/13/javap-%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</guid>
      <description>通过 javap 命令可以反编译 .class 文件，实际使用的时候 javap 后面的类名加与不加 .class 都可以。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -help --help -? 打印使用信息（也就是打印图中所示</description>
    </item>
    
    <item>
      <title>netstat 命令小记</title>
      <link>https://zhixiangyuan.github.io/2019/11/13/netstat-%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Wed, 13 Nov 2019 16:42:22 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/13/netstat-%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 只列出 TCP 套接字 # -t 选项可以只列出 TCP 的套接字，也可也用 --tcp $&amp;gt; netstat -at # 只列出 UDP 连接 #</description>
    </item>
    
    <item>
      <title>netcat 命令小记</title>
      <link>https://zhixiangyuan.github.io/2019/11/13/netcat-%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Wed, 13 Nov 2019 16:21:11 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/13/netcat-%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</guid>
      <description>netcat 因为功能强大，被称为网络工具中的瑞士军刀，nc 是 netcat 的简称。 1 2 3 4 5 6 7 8 9 10 11 12 # -l 参数表示 nc 将监听某个端口 # -p 表示监听的端口号为 $port $&amp;gt; nc</description>
    </item>
    
    <item>
      <title>通过 ssh 配置公网主机端口到内网主机端口的映射</title>
      <link>https://zhixiangyuan.github.io/2019/11/13/%E9%80%9A%E8%BF%87-ssh-%E9%85%8D%E7%BD%AE%E5%85%AC%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%AB%AF%E5%8F%A3%E5%88%B0%E5%86%85%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%98%A0%E5%B0%84/</link>
      <pubDate>Wed, 13 Nov 2019 14:33:39 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/13/%E9%80%9A%E8%BF%87-ssh-%E9%85%8D%E7%BD%AE%E5%85%AC%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%AB%AF%E5%8F%A3%E5%88%B0%E5%86%85%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%98%A0%E5%B0%84/</guid>
      <description>1 公网主机的配置修改 ssh 连接到公网主机，修改 sshd 的配置文件 /etc/ssh/sshd_config，在配置文件中找到 #GatewayPorts no 将其改为 GatewayPorts yes，如果没</description>
    </item>
    
    <item>
      <title>wireshark 的基本操作</title>
      <link>https://zhixiangyuan.github.io/2019/11/13/wireshark-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 13 Nov 2019 10:50:12 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/13/wireshark-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</guid>
      <description>1 抓包过滤 抓包的过程很耗 CPU 和内存资源而且大部分情况下我们不是对所有的包都感兴趣，因此可以只抓取满足特定条件的包，丢弃不感兴趣的包，比如只想抓</description>
    </item>
    
    <item>
      <title>以太网的帧格式</title>
      <link>https://zhixiangyuan.github.io/2019/11/12/%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E5%B8%A7%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Tue, 12 Nov 2019 23:08:25 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/12/%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E5%B8%A7%E6%A0%BC%E5%BC%8F/</guid>
      <description>1 以太网的帧格式 以太网的帧最小是 64 字节，除去 14 字节的头部（目标地址 + 源地址 + 长度类型）和 4 字节的 CRC 字段，有效荷载最小为 46 字节。最大帧为 1518 字节</description>
    </item>
    
    <item>
      <title>标准输入、标准输出与标准错误输出</title>
      <link>https://zhixiangyuan.github.io/2019/11/09/%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E4%B8%8E%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF%E8%BE%93%E5%87%BA/</link>
      <pubDate>Sat, 09 Nov 2019 16:50:59 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/09/%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E4%B8%8E%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF%E8%BE%93%E5%87%BA/</guid>
      <description>符号 含义 0 标准输入 1 标准输出 2 标准错误输出 0&amp;lt; 从标准输入中获取 1&amp;gt;&amp;lt;xxx&amp;gt; 将标准输出传输到 &amp;lt;xxx&amp;gt; 2&amp;gt;&amp;lt;xxx&amp;gt; 将标准错误输出输出到 &amp;lt;xxx&amp;gt; &amp;amp;&amp;gt;&amp;lt;xxx&amp;gt; 将标准输出和标准错误输出输出到 &amp;lt;xxx&amp;gt; /dev/null</description>
    </item>
    
    <item>
      <title>Base64 的编码方式</title>
      <link>https://zhixiangyuan.github.io/2019/11/09/base64-%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Sat, 09 Nov 2019 09:23:05 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/09/base64-%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/</guid>
      <description>1 Base64 使用场景 数据传输需要经过多个路由设备，不同设备的处理方式不同，为了防止处理不可见字符出现错误，所以使用 Base64 将数据转换成可见字符，防止传输中</description>
    </item>
    
    <item>
      <title>人活着到底在追求什么</title>
      <link>https://zhixiangyuan.github.io/2019/11/08/%E4%BA%BA%E6%B4%BB%E7%9D%80%E5%88%B0%E5%BA%95%E5%9C%A8%E8%BF%BD%E6%B1%82%E4%BB%80%E4%B9%88/</link>
      <pubDate>Fri, 08 Nov 2019 19:59:12 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/08/%E4%BA%BA%E6%B4%BB%E7%9D%80%E5%88%B0%E5%BA%95%E5%9C%A8%E8%BF%BD%E6%B1%82%E4%BB%80%E4%B9%88/</guid>
      <description>本文仅通过博主的所思所想写成，不具有任何指导意义，仅供参考。 人或者到底在追求什么，其实追根到底，应该是愉悦，而获取愉悦的三元素，便是名、利和</description>
    </item>
    
    <item>
      <title>Shell 脚本的参数传递</title>
      <link>https://zhixiangyuan.github.io/2019/11/07/shell-%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</link>
      <pubDate>Thu, 07 Nov 2019 09:10:09 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/07/shell-%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</guid>
      <description>1 Shell 编程中的参数引用 引用参数 描述 0, 1, 2&amp;hellip; 传递给脚本的参数位置，可以理解为传递进去的参数是个数组，通过数组下标取得参数 * 显示所有向脚本传递的参数</description>
    </item>
    
    <item>
      <title>Unset 命令</title>
      <link>https://zhixiangyuan.github.io/2019/11/06/unset-%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Wed, 06 Nov 2019 11:59:46 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/06/unset-%E5%91%BD%E4%BB%A4/</guid>
      <description>1 2 3 4 5 6 7 # 删除某个变量 $&amp;gt; unset &amp;lt;$变量名&amp;gt; # 或 $&amp;gt; unset -v &amp;lt;$变量名&amp;gt; # 删除某个函数 $&amp;gt; unset -f &amp;lt;$函数名&amp;gt; 案例：</description>
    </item>
    
    <item>
      <title>Env 命令</title>
      <link>https://zhixiangyuan.github.io/2019/11/06/env-%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Wed, 06 Nov 2019 11:44:09 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/06/env-%E5%91%BD%E4%BB%A4/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 # 输出所有的环境变量 $&amp;gt; env # 删除某个环境变量 # 运行某个命令在指定的环境变量下 $&amp;gt; env -u &amp;lt;$环境变量&amp;gt; [运行的命令]</description>
    </item>
    
    <item>
      <title>常见的环境变量</title>
      <link>https://zhixiangyuan.github.io/2019/11/06/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link>
      <pubDate>Wed, 06 Nov 2019 11:12:45 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/06/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid>
      <description>变量名 描述 HOME 用户的专属目录，在 linux 中用 ~ 扩展 PATH 外部命令的搜索路径 HISTSIZE 保存历史命令记录的条数 LOGNAME 当前用户的登录名 HOSTNAME 主机的名称，许多应用程序如果要用到</description>
    </item>
    
    <item>
      <title>Bash 启动时和登出时会运行的文件</title>
      <link>https://zhixiangyuan.github.io/2019/11/06/bash-%E5%90%AF%E5%8A%A8%E6%97%B6%E5%92%8C%E7%99%BB%E5%87%BA%E6%97%B6%E4%BC%9A%E8%BF%90%E8%A1%8C%E7%9A%84%E6%96%87%E4%BB%B6/</link>
      <pubDate>Wed, 06 Nov 2019 11:01:55 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/06/bash-%E5%90%AF%E5%8A%A8%E6%97%B6%E5%92%8C%E7%99%BB%E5%87%BA%E6%97%B6%E4%BC%9A%E8%BF%90%E8%A1%8C%E7%9A%84%E6%96%87%E4%BB%B6/</guid>
      <description>启动文件/登出文件 描述 /etc/profile 系统范围的默认值，大部分用来设置环境（所有由 sh 衍生出的 shell 均适用） /etc/bashrc 特定于 Bash 的，系统范围函数于别名 $HOME/.bash_profile 用户定义的，环境默</description>
    </item>
    
    <item>
      <title>Export 命令</title>
      <link>https://zhixiangyuan.github.io/2019/11/06/export-%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Wed, 06 Nov 2019 10:50:16 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/06/export-%E5%91%BD%E4%BB%A4/</guid>
      <description>1 语法 export [-fnp] [{$变量名称}={$变量的值}] 2 命令作用 设置环境变量，使用 export 设置的环境变量仅改变当前进程的环境，当前进程销毁则设置的环境变量失</description>
    </item>
    
    <item>
      <title>Echo 支持的转义字符</title>
      <link>https://zhixiangyuan.github.io/2019/11/06/echo-%E6%94%AF%E6%8C%81%E7%9A%84%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Wed, 06 Nov 2019 09:51:39 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/06/echo-%E6%94%AF%E6%8C%81%E7%9A%84%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</guid>
      <description>echo 需要加上 -e 才能够处理转义字符 转义字符 含义 \a 报警符，计算机会发出一声报警音 \b 退格符（Backspace） \c 禁止尾随，这个字符后面的所有字符都</description>
    </item>
    
    <item>
      <title>脑电双频指数</title>
      <link>https://zhixiangyuan.github.io/2019/11/06/%E8%84%91%E7%94%B5%E5%8F%8C%E9%A2%91%E6%8C%87%E6%95%B0/</link>
      <pubDate>Wed, 06 Nov 2019 07:20:22 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/06/%E8%84%91%E7%94%B5%E5%8F%8C%E9%A2%91%E6%8C%87%E6%95%B0/</guid>
      <description>脑电双频指数在监护仪上以字母“BIS”进行标识。 BIS = 100：患者处于完全清醒的状态。 BIS 处于 70～100 之间：患者处于轻度催眠状态，存在被唤醒</description>
    </item>
    
    <item>
      <title>Shell 中的变量</title>
      <link>https://zhixiangyuan.github.io/2019/11/05/shell-%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/</link>
      <pubDate>Tue, 05 Nov 2019 23:42:07 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/05/shell-%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/</guid>
      <description>1 变量的名称 shell 变量的名称以字母或下划线开始，后面可以接任意长度的字母、数字或下划线。 2 获取变量值 使用 $ 来获取变量值，如 $var，这种表示方式</description>
    </item>
    
    <item>
      <title>Shell 中的 #!</title>
      <link>https://zhixiangyuan.github.io/2019/11/05/shell-%E4%B8%AD%E7%9A%84-/</link>
      <pubDate>Tue, 05 Nov 2019 23:22:09 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/05/shell-%E4%B8%AD%E7%9A%84-/</guid>
      <description>1 #! 的作用 它的作用便是高所 shell 使用什么进程来执行此脚本 2 例子 2.1 echo Hello world 1 2 #!/bin/bash echo &amp;#34;Hello world!&amp;#34; 2.2 python 的 Hello world 1 2 #!/usr/bin/python print &amp;#34;Hello world!&amp;#34; 2.3 只会删除自己的脚本 1 2 3 #!/bin/rm # 这个 Hello world 打</description>
    </item>
    
    <item>
      <title>Shell 执行文件的三种方式</title>
      <link>https://zhixiangyuan.github.io/2019/11/05/shell-%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Tue, 05 Nov 2019 23:07:50 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/05/shell-%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
      <description>1 Shell 执行文件的三种方式 使文件具有可执行权限，直接运行文件 直接调用命令解释器执行文件，如 sh、bash 使用 source 执行文件 1.1 前两种执行文件的方式 前两</description>
    </item>
    
    <item>
      <title>MySQL 中的数据类型</title>
      <link>https://zhixiangyuan.github.io/2019/11/03/mysql-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sun, 03 Nov 2019 01:02:34 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/03/mysql-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>1 串数据类型 字符串数据类型必须括在引号内（通常为单引号，使用双引号也行）。 数据类型 说明 CHAR 1～255 个字符的定长串。它的长度必须在创建时指定，</description>
    </item>
    
    <item>
      <title>改善 MySQL 性能的建议</title>
      <link>https://zhixiangyuan.github.io/2019/11/03/%E6%94%B9%E5%96%84-mysql-%E6%80%A7%E8%83%BD%E7%9A%84%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Sun, 03 Nov 2019 00:51:01 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/03/%E6%94%B9%E5%96%84-mysql-%E6%80%A7%E8%83%BD%E7%9A%84%E5%BB%BA%E8%AE%AE/</guid>
      <description>MySQL（与所有 DBMS 一样）具有特定的硬件建议。在学习和研究MySQL时，使用任何旧的计算机作为服务器都可以。但对用于生产的服务器来说，应该坚</description>
    </item>
    
    <item>
      <title>MySQL 中的用户和权限管理</title>
      <link>https://zhixiangyuan.github.io/2019/11/02/mysql-%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sat, 02 Nov 2019 23:55:47 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/02/mysql-%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</guid>
      <description>1 用户管理 MySql 用户账号存储在名为 mysql 的 MySQL 数据库中，一般不需要直接访问 mysql 数据库和表，通过相关命令即可完成操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18</description>
    </item>
    
    <item>
      <title>MySQL 查看支持的字符集和校对顺序</title>
      <link>https://zhixiangyuan.github.io/2019/11/02/mysql-%E6%9F%A5%E7%9C%8B%E6%94%AF%E6%8C%81%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%A0%A1%E5%AF%B9%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>Sat, 02 Nov 2019 23:38:04 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/02/mysql-%E6%9F%A5%E7%9C%8B%E6%94%AF%E6%8C%81%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%A0%A1%E5%AF%B9%E9%A1%BA%E5%BA%8F/</guid>
      <description>1 2 3 4 5 -- 展示 MySQL 支持的字符集 SHOW CHARACTER SET; -- 展示 MySQL 支持的所有校对顺序 SHOW COLLATION;</description>
    </item>
    
    <item>
      <title>从系统架构角度对大脑的思考</title>
      <link>https://zhixiangyuan.github.io/2019/11/02/%E4%BB%8E%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%A7%92%E5%BA%A6%E5%AF%B9%E5%A4%A7%E8%84%91%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Sat, 02 Nov 2019 22:05:42 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/02/%E4%BB%8E%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%A7%92%E5%BA%A6%E5%AF%B9%E5%A4%A7%E8%84%91%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>现在一个比较通用系统架构都会用到数据库和缓存，对于外部的输入会先进入业务系统，最终根据存储策略打到缓存和数据库上。对于我这个大脑的用户而言，</description>
    </item>
    
    <item>
      <title>MySQL 事务管理</title>
      <link>https://zhixiangyuan.github.io/2019/11/02/mysql-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sat, 02 Nov 2019 21:21:35 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/02/mysql-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</guid>
      <description>1 事务管理 以下的语句是连接隔离的，每个连接都有自己的环境。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 -- 开始事务 START TRANSACTION; -- 事务回滚 ROLLBACK; -- 提交事务</description>
    </item>
    
    <item>
      <title>MySQL 存储过程的创建、执行和删除</title>
      <link>https://zhixiangyuan.github.io/2019/11/01/mysql-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%89%A7%E8%A1%8C%E5%92%8C%E5%88%A0%E9%99%A4/</link>
      <pubDate>Fri, 01 Nov 2019 18:39:30 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/01/mysql-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%89%A7%E8%A1%8C%E5%92%8C%E5%88%A0%E9%99%A4/</guid>
      <description>对于现在大多数的互联网应用，数据库的瓶颈在于数据库的读写，所以需要数据库尽快完成读写操作，业务操作放到服务器上做。 1 创建存储过程 1 2 3 4 5 6</description>
    </item>
    
    <item>
      <title>MySQL 视图的创建和删除</title>
      <link>https://zhixiangyuan.github.io/2019/11/01/mysql-%E8%A7%86%E5%9B%BE%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4/</link>
      <pubDate>Fri, 01 Nov 2019 16:45:48 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/01/mysql-%E8%A7%86%E5%9B%BE%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4/</guid>
      <description>视图便是临时表，在每次查看视图的时候执行指定的 SQL 语句。 1 视图的创建 1 2 -- 创建视图 CREATE VIEW &amp;lt;$view_name&amp;gt; AS &amp;lt;SELECT ...&amp;gt;; 2 视图的删除 1 2 -- 删除视图 DROP VIEW &amp;lt;$view_name&amp;gt;; 3 对视图中数据的</description>
    </item>
    
    <item>
      <title>世界上没有技术驱动型公司</title>
      <link>https://zhixiangyuan.github.io/2019/11/01/%E4%B8%96%E7%95%8C%E4%B8%8A%E6%B2%A1%E6%9C%89%E6%8A%80%E6%9C%AF%E9%A9%B1%E5%8A%A8%E5%9E%8B%E5%85%AC%E5%8F%B8/</link>
      <pubDate>Fri, 01 Nov 2019 14:08:41 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/01/%E4%B8%96%E7%95%8C%E4%B8%8A%E6%B2%A1%E6%9C%89%E6%8A%80%E6%9C%AF%E9%A9%B1%E5%8A%A8%E5%9E%8B%E5%85%AC%E5%8F%B8/</guid>
      <description>由于这篇文章写得太好，所以将该文章搬运过来作为备份，原文链接在参考资料中。以下为原文： 作者介绍： 智煜徽，洛林大学计算机专业研究生，现就职于华</description>
    </item>
    
    <item>
      <title>清除 Git 未追踪的文件和文件夹</title>
      <link>https://zhixiangyuan.github.io/2019/11/01/%E6%B8%85%E9%99%A4-git-%E6%9C%AA%E8%BF%BD%E8%B8%AA%E7%9A%84%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B9/</link>
      <pubDate>Fri, 01 Nov 2019 11:08:07 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/01/%E6%B8%85%E9%99%A4-git-%E6%9C%AA%E8%BF%BD%E8%B8%AA%E7%9A%84%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B9/</guid>
      <description>清除未追踪的文件使用 git clean 命令，git clean 有以下几个常用参数 1 2 3 -f # f 应该是 file 的缩写，表示删除未追踪的文件 -d # d 应该是 directory 的缩写，表示删除未追踪</description>
    </item>
    
    <item>
      <title>解决升级系统后 IntelliJ IDEA 报 Can&#39;t use Subversion command line client: svn 的问题</title>
      <link>https://zhixiangyuan.github.io/2019/11/01/%E8%A7%A3%E5%86%B3%E5%8D%87%E7%BA%A7%E7%B3%BB%E7%BB%9F%E5%90%8E-intellij-idea-%E6%8A%A5-cant-use-subversion-command-line-client-svn-%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 01 Nov 2019 10:00:53 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/01/%E8%A7%A3%E5%86%B3%E5%8D%87%E7%BA%A7%E7%B3%BB%E7%BB%9F%E5%90%8E-intellij-idea-%E6%8A%A5-cant-use-subversion-command-line-client-svn-%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>系统版本：macOS Catalina Version 10.15.1 在升级完系统后出现了下图中的错误 这个问题其实是由于命令行中 svn 命令失效导致的，在命令行中输入 svn 爆出以下错误 1 xcrun: error: invalid active</description>
    </item>
    
    <item>
      <title>反斜杠 r 与 反斜杠 n 的含义</title>
      <link>https://zhixiangyuan.github.io/2019/10/31/%E5%8F%8D%E6%96%9C%E6%9D%A0-r-%E4%B8%8E-%E5%8F%8D%E6%96%9C%E6%9D%A0-n-%E7%9A%84%E5%90%AB%E4%B9%89/</link>
      <pubDate>Thu, 31 Oct 2019 20:39:40 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/31/%E5%8F%8D%E6%96%9C%E6%9D%A0-r-%E4%B8%8E-%E5%8F%8D%E6%96%9C%E6%9D%A0-n-%E7%9A%84%E5%90%AB%E4%B9%89/</guid>
      <description>1 \r \n 的来历 在计算机还没有出现之前，有一种叫做电传打自己的东西，每秒钟可以打 10 个字符，每个字符 0.1 秒，但是他有一个问题，就是换行的时候需要 0.2 秒</description>
    </item>
    
    <item>
      <title>MySQL 创建表、修改表和删除表</title>
      <link>https://zhixiangyuan.github.io/2019/10/31/mysql-%E5%88%9B%E5%BB%BA%E8%A1%A8%E4%BF%AE%E6%94%B9%E8%A1%A8%E5%92%8C%E5%88%A0%E9%99%A4%E8%A1%A8/</link>
      <pubDate>Thu, 31 Oct 2019 15:22:49 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/31/mysql-%E5%88%9B%E5%BB%BA%E8%A1%A8%E4%BF%AE%E6%94%B9%E8%A1%A8%E5%92%8C%E5%88%A0%E9%99%A4%E8%A1%A8/</guid>
      <description>1 创建表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 CREATE TABLE [IF NOT EXISTS] &amp;lt;table_name&amp;gt; ( &amp;lt;field_name&amp;gt; &amp;lt;data_type&amp;gt;[size] [NOT NULL|NULL] [DEFAULT &amp;lt;value&amp;gt;] [AUTO_INCREMENT] [COMMENT &amp;lt;comment&amp;gt;] [CHARACTER SET &amp;lt;charset&amp;gt;] [COLLATE &amp;lt;collate&amp;gt;] [UNSIGNED], [field_name data_type]...</description>
    </item>
    
    <item>
      <title>MySQL UPDATE、DELETE 与 TRUNCATE 的使用</title>
      <link>https://zhixiangyuan.github.io/2019/10/31/mysql-updatedelete-%E4%B8%8E-truncate-%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 31 Oct 2019 10:39:22 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/31/mysql-updatedelete-%E4%B8%8E-truncate-%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>1 UPDATE 语句的使用 注意：UPDATE 语句的使用一定要小心，因为一不小心你可能就更新了表中的所有数据。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22</description>
    </item>
    
    <item>
      <title>MySQL INSERT 与 REPLACE 的使用</title>
      <link>https://zhixiangyuan.github.io/2019/10/31/mysql-insert-%E4%B8%8E-replace-%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 31 Oct 2019 10:05:58 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/31/mysql-insert-%E4%B8%8E-replace-%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>1 INSERT 语句的使用 1.1 插入单条数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 查看表结构 mysql&amp;gt; SELECT * FROM prods; +----+------------+ | id | prod_name | +----+------------+ | 1 | apple | | 2 | banana | | 3</description>
    </item>
    
    <item>
      <title>MySQL 中的连接查询</title>
      <link>https://zhixiangyuan.github.io/2019/10/30/mysql-%E4%B8%AD%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Wed, 30 Oct 2019 14:02:29 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/30/mysql-%E4%B8%AD%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/</guid>
      <description>1 交叉连接：CROSS JOIN 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 交叉连接使用这个数据表 mysql&amp;gt; SELECT * FROM orders; +----+---------+ | id | cust_id | +----+---------+ | 1 | 1 | | 2 | NULL | +----+---------+ mysql&amp;gt; SELECT * FROM customers; +----+-----------------+---------------+ | id</description>
    </item>
    
    <item>
      <title>MySQL 中子查询的使用</title>
      <link>https://zhixiangyuan.github.io/2019/10/30/mysql-%E4%B8%AD%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 30 Oct 2019 10:43:43 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/30/mysql-%E4%B8%AD%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>1 测试用例使用的数据表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 # 客户表，存储客户的信息 mysql&amp;gt; SELECT * FROM</description>
    </item>
    
    <item>
      <title>MySQL 中的聚集函数</title>
      <link>https://zhixiangyuan.github.io/2019/10/29/mysql-%E4%B8%AD%E7%9A%84%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 29 Oct 2019 11:08:19 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/29/mysql-%E4%B8%AD%E7%9A%84%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0/</guid>
      <description>1 MySQL 中的聚集函数 函数 说明 AVG([DISTINCT or ALL] &amp;lt;field&amp;gt;) 返回某列的平均值 COUNT([DISTINCT or ALL] &amp;lt;field&amp;gt;) 返回某列的行数 MAX(&amp;lt;field&amp;gt;) 返回某列的最大值 MIN(&amp;lt;field&amp;gt;) 返回某列的最小值 SUM([DISTINCT or ALL] &amp;lt;field&amp;gt;) 返回某列值之和 DISTINCT 参数起到去</description>
    </item>
    
    <item>
      <title>MySQL 数值处理函数</title>
      <link>https://zhixiangyuan.github.io/2019/10/29/mysql-%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 29 Oct 2019 10:04:43 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/29/mysql-%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</guid>
      <description>1 数值处理函数 函数 说明 Abs(&amp;lt;number&amp;gt;) 返回一个数的绝对值 Exp(&amp;lt;number&amp;gt;) 返回一个数的指数值，等同于 \(e^{[number]}\) Mod(&amp;lt;number1&amp;gt;, &amp;lt;number2&amp;gt;) 返回除操作的余数 Pi() 返回圆周率 Rand() 返回一个随机数，范围在 [0,1) Cos(&amp;lt;number&amp;gt;) 返回一个</description>
    </item>
    
    <item>
      <title>程序员的标准与要求</title>
      <link>https://zhixiangyuan.github.io/2019/10/29/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%A0%87%E5%87%86%E4%B8%8E%E8%A6%81%E6%B1%82/</link>
      <pubDate>Tue, 29 Oct 2019 09:51:52 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/29/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%A0%87%E5%87%86%E4%B8%8E%E8%A6%81%E6%B1%82/</guid>
      <description>1 初级程序员 仅能完成简单模块和项目的开发工作，难以胜任复杂模块的开发。通常是入行不久， 1 年及以下工作经验的同学。 1.1 能力要求 熟悉前端基础知识如</description>
    </item>
    
    <item>
      <title>MySQL 日期和时间处理函数</title>
      <link>https://zhixiangyuan.github.io/2019/10/28/mysql-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 28 Oct 2019 20:37:26 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/28/mysql-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</guid>
      <description>1 日期和时间处理函数 函数 说明 Date(&amp;lt;field&amp;gt;) 返回日期时间的日期部分 Time(&amp;lt;field&amp;gt;) 返回一个日期时间的时间部分 Year(&amp;lt;field&amp;gt;) 返回一个日期的年份部分 Month(&amp;lt;field&amp;gt;) 返回一个日期的月份部分 Day(&amp;lt;field&amp;gt;) 返回一个日</description>
    </item>
    
    <item>
      <title>MySQL 控制以及查看状态的命令</title>
      <link>https://zhixiangyuan.github.io/2019/10/28/mysql-%E6%8E%A7%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%9F%A5%E7%9C%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 28 Oct 2019 18:19:32 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/28/mysql-%E6%8E%A7%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%9F%A5%E7%9C%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%91%BD%E4%BB%A4/</guid>
      <description>1 一组 SHOW 命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64</description>
    </item>
    
    <item>
      <title>MySQL 文本处理函数</title>
      <link>https://zhixiangyuan.github.io/2019/10/28/mysql-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 28 Oct 2019 15:32:01 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/28/mysql-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</guid>
      <description>1 文本处理函数 函数 说明 Left(&amp;lt;field&amp;gt;, &amp;lt;length&amp;gt;) 返回字符串左边的字符 Right(&amp;lt;field&amp;gt;, &amp;lt;length&amp;gt;) 返回字符串右边的字符 Length(&amp;lt;field&amp;gt;) 返回字符串的长度 Locate(&amp;lt;subStr&amp;gt;, &amp;lt;field&amp;gt;) 找出字符串的一个子串 Lower(&amp;lt;field&amp;gt;) 将字符串转换为小写 Upper(&amp;lt;field&amp;gt;) 将字符</description>
    </item>
    
    <item>
      <title>MySQL SELECT 的使用</title>
      <link>https://zhixiangyuan.github.io/2019/10/28/mysql-select-%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 28 Oct 2019 09:53:55 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/28/mysql-select-%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>1 SELECT 命令浅析 1 2 3 4 5 6 7 8 9 10 # 检索单列数据 mysql&amp;gt; SELECT &amp;lt;field&amp;gt; FROM &amp;lt;table&amp;gt;; # 检索多列数据，列与列之间用 &amp;#39;,&amp;#39; 隔开即可 # 注意：最后一个列名后面不需要加逗号 mysql&amp;gt; SELECT &amp;lt;field&amp;gt;,&amp;lt;field&amp;gt; FROM &amp;lt;table&amp;gt;;</description>
    </item>
    
    <item>
      <title>Redis 中的数据结构</title>
      <link>https://zhixiangyuan.github.io/2019/10/27/redis-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 27 Oct 2019 13:06:22 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/27/redis-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>1 Redis 中的数据结构 redis 中的数据结构是 key value 形式的，key 是字符串，value 有五种数据结构 string list hash set sorted set 2 Redis 中底层的数据结构 简单动态字符串（SDS）</description>
    </item>
    
    <item>
      <title>MySQL 三大引擎</title>
      <link>https://zhixiangyuan.github.io/2019/10/27/mysql-%E4%B8%89%E5%A4%A7%E5%BC%95%E6%93%8E/</link>
      <pubDate>Sun, 27 Oct 2019 11:16:36 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/27/mysql-%E4%B8%89%E5%A4%A7%E5%BC%95%E6%93%8E/</guid>
      <description>MySQL 常用的引擎有 InnoDB、MyISAM、Memory，默认是 InnoDB 1 InnoDB 这种引擎序列化在磁盘中，支持事务，支持行级锁，B+Tree 索引。拥有良好</description>
    </item>
    
    <item>
      <title>SSL 加密流程简述</title>
      <link>https://zhixiangyuan.github.io/2019/10/27/ssl-%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/</link>
      <pubDate>Sun, 27 Oct 2019 10:51:23 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/27/ssl-%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/</guid>
      <description>SSL 加密的思想运用到了对称加密和非对称加密，非堆成加密的优势在于没有私钥则无法解密，所以想要传输信息的一端只需要拿到公钥就可以完成加密传输，但</description>
    </item>
    
    <item>
      <title>Http 协议格式</title>
      <link>https://zhixiangyuan.github.io/2019/10/27/http-%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Sun, 27 Oct 2019 10:01:55 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/27/http-%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F/</guid>
      <description>1 HTTP 请求报文 HTTP 请求报文由请求行、请求头部、空行和请求包体 4 个部分组成，如下图所示： 1.1 请求行 请求行由方法字段、URL 字段和 HTTP 协议版本字段 3 个部</description>
    </item>
    
    <item>
      <title>Java 中的类加载器</title>
      <link>https://zhixiangyuan.github.io/2019/10/26/java-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</link>
      <pubDate>Sat, 26 Oct 2019 21:55:24 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/26/java-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid>
      <description>Java 中的类加载器分为三种： 启动类加载器 扩展类加载器 应用程序类加载器 1 启动类加载器 Bootstrap ClassLoader，C 语言实现，用于加载 JDK\jre\lib\rt.jar 2 扩展类加载器</description>
    </item>
    
    <item>
      <title>类的加载过程</title>
      <link>https://zhixiangyuan.github.io/2019/10/26/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Sat, 26 Oct 2019 21:54:10 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/26/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</guid>
      <description>类的加载分为以下五个步骤： 加载 连接 初始化 使用 卸载 1 加载 加载操作会去加载类的二进制数据到内存中，然后在堆中开辟出一个 java.lang.Class 对象 2 连接 连接又包含三个</description>
    </item>
    
    <item>
      <title>JVM 内存模型</title>
      <link>https://zhixiangyuan.github.io/2019/10/26/jvm-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sat, 26 Oct 2019 21:42:18 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/26/jvm-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>JVM 的内存模型分为主内存和线程的工作内存两大块，这属于一个抽象的内存模型，用于解决并发问题，与 JVM 中的内存结构如堆、栈没什么关系，不要弄混。 参考</description>
    </item>
    
    <item>
      <title>字符串常量池</title>
      <link>https://zhixiangyuan.github.io/2019/10/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/</link>
      <pubDate>Sat, 26 Oct 2019 21:23:31 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/</guid>
      <description>JVM 为了提高性能和减少内存开销，实现数据共享，所以引入了字符串常量池。字符串常量池存在于方法区当中，创建字符串常量时，首先判断字符串是否存在于</description>
    </item>
    
    <item>
      <title>JVM 堆内存中的结构</title>
      <link>https://zhixiangyuan.github.io/2019/10/26/jvm-%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sat, 26 Oct 2019 20:43:53 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/26/jvm-%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84/</guid>
      <description>1 堆内存结构 堆内存中分为三块，分别是年轻代、老年代和方法区，Java 堆不需要连续的内存，可以动态增加内存，增加失败则抛出 OutOfMemoryError 异常 1.1 年轻代与老年</description>
    </item>
    
    <item>
      <title>常见的垃圾回收算法</title>
      <link>https://zhixiangyuan.github.io/2019/10/26/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 26 Oct 2019 20:34:00 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/26/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</guid>
      <description>1 标记清除算法 标记清除算法有两个阶段，标记阶段和回收阶段。标记阶段将需要被清除的对象打上标签，回收阶段完成对于对象的回收。这种算法回收过后会</description>
    </item>
    
    <item>
      <title>常见垃圾回收器</title>
      <link>https://zhixiangyuan.github.io/2019/10/26/%E5%B8%B8%E8%A7%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</link>
      <pubDate>Sat, 26 Oct 2019 20:29:08 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/26/%E5%B8%B8%E8%A7%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</guid>
      <description>Serial Garbage Collector: 单线程 GC Parallel Garbage Collector: 多线程 GC CMS Garbage Collector: 多线程 GC G1 Garbage Collector: jdk7 引进的 GC 优点：多线程运行，适合高并发场景，暂停时间短 目标：逐步取代 CMS GC</description>
    </item>
    
    <item>
      <title>JVM 中如何判断对象生死</title>
      <link>https://zhixiangyuan.github.io/2019/10/26/jvm-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E7%94%9F%E6%AD%BB/</link>
      <pubDate>Sat, 26 Oct 2019 20:06:39 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/26/jvm-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E7%94%9F%E6%AD%BB/</guid>
      <description>1 引用器计数法 如果某个引用被别的引用引用一次，那么引用计数器就加一，引用计数器为 0 时便回收对象。 这种方法有缺陷，如果出现循环引用，那么 GC 便无</description>
    </item>
    
    <item>
      <title>RabbitMQ 的四种交换机类型</title>
      <link>https://zhixiangyuan.github.io/2019/10/26/rabbitmq-%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 26 Oct 2019 11:09:38 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/26/rabbitmq-%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B/</guid>
      <description>消息在 RabbitMQ 中的运动流程是先从生产者推送消息到交换机，交换机再将消息路由到队列，最后消费者消费队列中的消息。 RabbitMQ 的交换机类型分为四种： 扇形交换机：</description>
    </item>
    
    <item>
      <title>一条好用的 Git 别名命令</title>
      <link>https://zhixiangyuan.github.io/2019/10/25/%E4%B8%80%E6%9D%A1%E5%A5%BD%E7%94%A8%E7%9A%84-git-%E5%88%AB%E5%90%8D%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Fri, 25 Oct 2019 13:32:41 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/25/%E4%B8%80%E6%9D%A1%E5%A5%BD%E7%94%A8%E7%9A%84-git-%E5%88%AB%E5%90%8D%E5%91%BD%E4%BB%A4/</guid>
      <description>1 2 $&amp;gt; git config --global alias.loginfo &amp;#34;log --pretty=format:&amp;#39;%C(auto) %h | %ai | %Cred %an %Cgreen %s %C(auto) %d&amp;#39; --date=local&amp;#34; # 使用时输入 git loginfo 该命令是对于 git log 界面的格式化，格式化之后显示效果看起来更舒服，下图是命令执行过后看起</description>
    </item>
    
    <item>
      <title>Java 中的桥接方法</title>
      <link>https://zhixiangyuan.github.io/2019/10/23/java-%E4%B8%AD%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 23 Oct 2019 10:40:51 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/23/java-%E4%B8%AD%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%96%B9%E6%B3%95/</guid>
      <description>先看下面的接口与接口实现 1 2 3 4 5 6 7 8 9 10 public interface AInterface&amp;lt;T&amp;gt; { void func(T t); } public class AClass implements AInterface&amp;lt;String&amp;gt; { @Override public void func(String s) { System.out.println(s); } } 由于 Java 的泛型是要擦除的，所以当虚拟机看到的时候其实</description>
    </item>
    
    <item>
      <title>XPath 解析器示例</title>
      <link>https://zhixiangyuan.github.io/2019/10/22/xpath-%E8%A7%A3%E6%9E%90%E5%99%A8%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Tue, 22 Oct 2019 16:25:33 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/22/xpath-%E8%A7%A3%E6%9E%90%E5%99%A8%E7%A4%BA%E4%BE%8B/</guid>
      <description>1 XPath 解析器示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63</description>
    </item>
    
    <item>
      <title>MyBatis 源码结构</title>
      <link>https://zhixiangyuan.github.io/2019/10/22/mybatis-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/</link>
      <pubDate>Tue, 22 Oct 2019 10:34:21 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/22/mybatis-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/</guid>
      <description>1 MyBatis 整体架构 MyBatis 的整体架构分为三层： 基础支持层 核心处理层 接口层 三层结构如下图所示： MyBatis 源码包结构： 1.1 基础支持层 基础支持层，包含整个 MyBatis 的基础模块，</description>
    </item>
    
    <item>
      <title>RabbitMQ 客户端开发向导</title>
      <link>https://zhixiangyuan.github.io/2019/10/21/rabbitmq-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91%E5%90%91%E5%AF%BC/</link>
      <pubDate>Mon, 21 Oct 2019 11:12:48 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/21/rabbitmq-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91%E5%90%91%E5%AF%BC/</guid>
      <description>1 引入依赖 1 2 3 4 5 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.rabbitmq&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;amqp-client&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.4.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 2 连接 RabbitMQ 2.1 通过给定参数来连接 1 2 3 4 5 6 7 ConnectionFactory factory = new ConnectionFactory(); factory.setUsername(&amp;#34;&amp;lt;username&amp;gt;&amp;#34;); factory.setPassword(&amp;#34;&amp;lt;password&amp;gt;&amp;#34;); factory.setVirtualHost(&amp;#34;&amp;lt;virtual_host&amp;gt;&amp;#34;); factory.setHost(&amp;#34;&amp;lt;host&amp;gt;&amp;#34;); factory.setPort(5672); Connection connection = factory.newConnection(); 2.2 通过给定 URI 的方式来连接 1 2 3 4 5 ConnectionFactory factory =</description>
    </item>
    
    <item>
      <title>ThreadLocal 源码浅析与其使用场景</title>
      <link>https://zhixiangyuan.github.io/2019/10/18/threadlocal-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%E4%B8%8E%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Fri, 18 Oct 2019 16:36:38 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/18/threadlocal-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%E4%B8%8E%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</guid>
      <description>1 源码浅析 ThreadLocal 用于不同线程存储不同的线程全局变量，在该线程下用 ThreadLocal 取出的值是一致的。这里先简述一下原理，然后再看代码。ThreadLocal 其实</description>
    </item>
    
    <item>
      <title>缓存设计</title>
      <link>https://zhixiangyuan.github.io/2019/10/15/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Tue, 15 Oct 2019 11:10:06 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/15/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/</guid>
      <description>1 缓存的收益和成本分析 缓存架构流程图 1.1 缓存的收益 加速读写：因为缓存通常是全内存的，而存储层通常性能不够强悍，通过缓存的使用可以有效的加速读写</description>
    </item>
    
    <item>
      <title>制作 MacOS 安装盘</title>
      <link>https://zhixiangyuan.github.io/2019/10/14/%E5%88%B6%E4%BD%9C-macos-%E5%AE%89%E8%A3%85%E7%9B%98/</link>
      <pubDate>Mon, 14 Oct 2019 15:19:45 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/14/%E5%88%B6%E4%BD%9C-macos-%E5%AE%89%E8%A3%85%E7%9B%98/</guid>
      <description>第一步，在网上或者 app store 中找到 macos 镜像，然后下载 第二步，通过命令进行制作安装盘，命令如下，输完命令等待几十分钟即可。 1 2 3 $&amp;gt; &amp;lt;安装包位置&amp;</description>
    </item>
    
    <item>
      <title>Redis 中的数据复制</title>
      <link>https://zhixiangyuan.github.io/2019/10/14/redis-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Mon, 14 Oct 2019 11:19:41 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/14/redis-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/</guid>
      <description>1 数据复制 1.1 建立复制 在从节点的配置文件中加入以下配置，然后启动即可 slaveof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt; 启动过后通过 info replication 查看节点信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20</description>
    </item>
    
    <item>
      <title>Linux 中的系统调用</title>
      <link>https://zhixiangyuan.github.io/2019/10/14/linux-%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</link>
      <pubDate>Mon, 14 Oct 2019 10:05:02 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/14/linux-%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</guid>
      <description>1 系统调用 fork: 创建进程 execve: 执行任务 waitpid: 通过将子进程的进程号传给它来了解子进程运行是否完成，是否成功 brk: 分配一块与原来堆数据连在一起的内存空间 mmap: 分配一</description>
    </item>
    
    <item>
      <title>Shell 中的字符串处理</title>
      <link>https://zhixiangyuan.github.io/2019/10/13/shell-%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</link>
      <pubDate>Sun, 13 Oct 2019 19:27:09 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/13/shell-%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</guid>
      <description>1 字符串截取 使用 %、# 实现字符串截取 1.1 % ${variable%pattern}，这种模式时，shell 在 variable 中查找，看它是否以给的模式 pattern 结尾，</description>
    </item>
    
    <item>
      <title>Shell 中的三目运算符</title>
      <link>https://zhixiangyuan.github.io/2019/10/13/shell-%E4%B8%AD%E7%9A%84%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Sun, 13 Oct 2019 19:01:27 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/13/shell-%E4%B8%AD%E7%9A%84%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>shell 中的三目运算符有四种，分别是 :-、:+、:=、:?，下面分别举例 1 :- ${var:-string} 对于这种表达式表示若 $var 为空则使用 string 替换 ${var:-string}，</description>
    </item>
    
    <item>
      <title>Redis 的持久化</title>
      <link>https://zhixiangyuan.github.io/2019/10/12/redis-%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</link>
      <pubDate>Sat, 12 Oct 2019 16:18:42 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/12/redis-%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</guid>
      <description>Redis 的持久化机制分为两种，RDB 和 AOF 1 RDB RDB 是将当前进程数据生成快照保存到硬盘的过程，触发 RDB 持久化过程分为手动触发和自动触发。 1.1 触发机制 1.1.1 手动触</description>
    </item>
    
    <item>
      <title>Linux 基础</title>
      <link>https://zhixiangyuan.github.io/2019/10/12/linux-%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sat, 12 Oct 2019 13:04:55 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/12/linux-%E5%9F%BA%E7%A1%80/</guid>
      <description>useradd 1 2 3 4 5 # 新建用户 $&amp;gt; useradd &amp;lt;usrename&amp;gt; # 新建用户，并将用户加入指定的组 # 组名必须存在，否则会提示不存在 $&amp;gt; useradd &amp;lt;username&amp;gt; -g &amp;lt;groupname&amp;gt; passwd 1 2 3 4 # 更改当前用户的密码 $&amp;gt; passwd # 更</description>
    </item>
    
    <item>
      <title>Redis 客户端的管理</title>
      <link>https://zhixiangyuan.github.io/2019/10/11/redis-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%AE%A1%E7%90%86/</link>
      <pubDate>Fri, 11 Oct 2019 15:06:55 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/11/redis-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%AE%A1%E7%90%86/</guid>
      <description>1 Jedis 的基本使用 首先引入包 1 2 3 4 5 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 基本使用 1 2 3 4 5 6 7 8 public static void main(String[] args) { Jedis jedis = new Jedis(IP, PORT); // 后面通过 jedis 中提供的各种方法就可以直接操作 redis 了 String</description>
    </item>
    
    <item>
      <title>Redis 客户端通信协议</title>
      <link>https://zhixiangyuan.github.io/2019/10/11/redis-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Fri, 11 Oct 2019 13:30:14 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/11/redis-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</guid>
      <description>redis 的协议客户端通信协议称为 RESP（Redis Serialization Protocol），这种协议简单高效即能被机器解析，又能被人类识别。 1 发送命令的格式 CRLF 指的是</description>
    </item>
    
    <item>
      <title>命令行潜规则</title>
      <link>https://zhixiangyuan.github.io/2019/10/10/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BD%9C%E8%A7%84%E5%88%99/</link>
      <pubDate>Thu, 10 Oct 2019 16:33:08 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/10/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BD%9C%E8%A7%84%E5%88%99/</guid>
      <description>本文所述的内容适用于本博客的标记方式 符号 含义 尖括号 &amp;lt;&amp;gt; 必选参数，实际使用时应将其替换为所需要的参数 方括号 [] 可选参数，实际使用时应将其替换为所需</description>
    </item>
    
    <item>
      <title>Redis 中的 GEO 功能</title>
      <link>https://zhixiangyuan.github.io/2019/10/10/redis-%E4%B8%AD%E7%9A%84-geo-%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Thu, 10 Oct 2019 15:38:27 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/10/redis-%E4%B8%AD%E7%9A%84-geo-%E5%8A%9F%E8%83%BD/</guid>
      <description>通过 GEO 功能可以实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能，对于需要实现这些功能的开发者来说是一大福音。 1 命令 1.1 添加地理位置信息 geoadd &amp;lt;key&amp;gt;</description>
    </item>
    
    <item>
      <title>Redis 中的发布订阅模式</title>
      <link>https://zhixiangyuan.github.io/2019/10/10/redis-%E4%B8%AD%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 10 Oct 2019 15:04:46 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/10/redis-%E4%B8%AD%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>redis 提供发布消息、订阅消息、取消订阅、按照模式订阅和取消订阅和查阅订阅的功能 1 命令 1.1 发布消息 publish &amp;lt;channel&amp;gt; &amp;lt;message&amp;gt; 1 2 3 # 下面的命令向 channel:sports 频道发布一条消息 &amp;#34;Tim won the</description>
    </item>
    
    <item>
      <title>Redis 中的 HyperLogLog</title>
      <link>https://zhixiangyuan.github.io/2019/10/10/redis-%E4%B8%AD%E7%9A%84-hyperloglog/</link>
      <pubDate>Thu, 10 Oct 2019 14:22:00 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/10/redis-%E4%B8%AD%E7%9A%84-hyperloglog/</guid>
      <description>HyperLogLog 并不是数据结构而是一种基数算法，通过 HyperLogLog 可以利用极小的内存空间完成独立总数的统计，数据集可以是 IP、Email、ID 等。HyperLogLo</description>
    </item>
    
    <item>
      <title>Redis 中的 Bitmaps</title>
      <link>https://zhixiangyuan.github.io/2019/10/10/redis-%E4%B8%AD%E7%9A%84-bitmaps/</link>
      <pubDate>Thu, 10 Oct 2019 12:47:37 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/10/redis-%E4%B8%AD%E7%9A%84-bitmaps/</guid>
      <description>1 存储 bitmap 的数据结构 其实就是普通的 string，只不过可以通过 bitmap 来操作二进制位为 0 或 1，比如说下面这个例子 1 2 3 4 5 6 7 8 # 先设置一个键值对 $redis-cli&amp;gt;set</description>
    </item>
    
    <item>
      <title>Redis 中的 Pipeline</title>
      <link>https://zhixiangyuan.github.io/2019/10/10/redis-%E4%B8%AD%E7%9A%84-pipeline/</link>
      <pubDate>Thu, 10 Oct 2019 10:45:25 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/10/redis-%E4%B8%AD%E7%9A%84-pipeline/</guid>
      <description>1 为什么要有 pipeline 要了解这个问题首先需要了解 redis 性能瓶颈在哪里，其实，redis 性能问题很多时候在网络传输上，我来计算一下为什么会这样。首先 redis 客户</description>
    </item>
    
    <item>
      <title>Redis 提供的命令行工具</title>
      <link>https://zhixiangyuan.github.io/2019/10/09/redis-%E6%8F%90%E4%BE%9B%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 09 Oct 2019 18:33:21 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/09/redis-%E6%8F%90%E4%BE%9B%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid>
      <description>1 redis-server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 直接运行 $&amp;gt; redis-server # 可以在后面指定配置然后运行 $&amp;gt; redis-server --configKey1 configValue1 --configKey2 configValue2 # 比如说修改端口号 $&amp;gt; redis-server --port 4500 # 指定配置文件启动 $&amp;gt; redis-server</description>
    </item>
    
    <item>
      <title>Redis 慢查询相关配置与命令</title>
      <link>https://zhixiangyuan.github.io/2019/10/09/redis-%E6%85%A2%E6%9F%A5%E8%AF%A2%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Wed, 09 Oct 2019 17:54:45 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/09/redis-%E6%85%A2%E6%9F%A5%E8%AF%A2%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%91%BD%E4%BB%A4/</guid>
      <description>1 相关配置 配置有两个，分别是 slowlog-log-slower-than 和 slowlog-max-len，两个配置的含义如下 slowlog-log-slower-than: 超过这个时间的查询为慢查询，时间单位为微秒 slowlog-max-len: 保存的慢查询</description>
    </item>
    
    <item>
      <title>布偶猫的颜色花纹分类</title>
      <link>https://zhixiangyuan.github.io/2019/10/07/%E5%B8%83%E5%81%B6%E7%8C%AB%E7%9A%84%E9%A2%9C%E8%89%B2%E8%8A%B1%E7%BA%B9%E5%88%86%E7%B1%BB/</link>
      <pubDate>Mon, 07 Oct 2019 17:23:57 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/07/%E5%B8%83%E5%81%B6%E7%8C%AB%E7%9A%84%E9%A2%9C%E8%89%B2%E8%8A%B1%E7%BA%B9%E5%88%86%E7%B1%BB/</guid>
      <description>影响布偶猫的外形主要有三个因素，分别是颜色、色块位置、是否有山猫纹，下面一一举例 1 颜色分类 颜色大的方向分为黑色系、巧克力色系、红色系、玳瑁色</description>
    </item>
    
    <item>
      <title>路西法效应</title>
      <link>https://zhixiangyuan.github.io/2019/10/06/%E8%B7%AF%E8%A5%BF%E6%B3%95%E6%95%88%E5%BA%94/</link>
      <pubDate>Sun, 06 Oct 2019 12:51:54 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/06/%E8%B7%AF%E8%A5%BF%E6%B3%95%E6%95%88%E5%BA%94/</guid>
      <description>1 环境使人走向邪恶的七步 无意中迈出的第一步 对他人去人性化 对自己去个体化 推卸个人责任 盲目服从权威 不加批判的遵从群体规范 对恶行为袖手旁观，消极容</description>
    </item>
    
    <item>
      <title>谈论行业的文章汇总</title>
      <link>https://zhixiangyuan.github.io/2019/10/05/%E8%B0%88%E8%AE%BA%E8%A1%8C%E4%B8%9A%E7%9A%84%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/</link>
      <pubDate>Sat, 05 Oct 2019 21:46:53 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/05/%E8%B0%88%E8%AE%BA%E8%A1%8C%E4%B8%9A%E7%9A%84%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/</guid>
      <description>1 浅谈程序员的行业选择 &amp;mdash; 程序人生 该文章中将行业分为了互联网、甲方、乙方和游戏，同时，互联网又被分成传统互联网和移动互联网。对于互联网企业，文</description>
    </item>
    
    <item>
      <title>Class 方法之 forName(String className) 小记</title>
      <link>https://zhixiangyuan.github.io/2019/10/04/class-%E6%96%B9%E6%B3%95%E4%B9%8B-fornamestring-classname-%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Fri, 04 Oct 2019 20:29:08 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/04/class-%E6%96%B9%E6%B3%95%E4%B9%8B-fornamestring-classname-%E5%B0%8F%E8%AE%B0/</guid>
      <description>Class.forName(String className) 这个方法的作用就是触发类的初始化动作 1 2 public static Class&amp;lt;?&amp;gt; forName(String className) throws ClassNotFoundException 这个方法目前就仅在 JDBC 的初始化的时候见过，他的目的就是触发 JDBC 驱动注册到代码中，代码如</description>
    </item>
    
    <item>
      <title>Vim 命令小记</title>
      <link>https://zhixiangyuan.github.io/2019/09/25/vim-%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Wed, 25 Sep 2019 09:54:44 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/09/25/vim-%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</guid>
      <description>1 移动命令 1.1 行间搜索移动 f${char} 移动到 char 字符的第一个字母上 t${char} 移动到 char 字符的第一个字母前面 &amp;rsquo;;&amp;rsquo; 配合 f 和 t 搜索该行的下一个 &amp;rsquo;,&amp;rsquo; 配合 f 和 t 搜索该行的上一个 1.2</description>
    </item>
    
    <item>
      <title>Monitorenter 与 Monitorexit 小记</title>
      <link>https://zhixiangyuan.github.io/2019/09/23/monitorenter-%E4%B8%8E-monitorexit-%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Mon, 23 Sep 2019 10:07:48 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/09/23/monitorenter-%E4%B8%8E-monitorexit-%E5%B0%8F%E8%AE%B0/</guid>
      <description>首先对如下代码进行编译 1 2 3 4 5 public void Test() { synchronized(this) { System.out.println(); } } 将得到的字节码通过 javap 反编译 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public void</description>
    </item>
    
    <item>
      <title>Ant 风格路径表达式</title>
      <link>https://zhixiangyuan.github.io/2019/09/22/ant-%E9%A3%8E%E6%A0%BC%E8%B7%AF%E5%BE%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sun, 22 Sep 2019 10:57:53 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/09/22/ant-%E9%A3%8E%E6%A0%BC%E8%B7%AF%E5%BE%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>Ant 风格路径表达式就是一个精简版的正则表达式 通配符 说明 ? 匹配任何单字符 * 匹配 0 或者任意数量的字符 ** 匹配 0 或者更多的目录</description>
    </item>
    
    <item>
      <title>如何在 Spring 的 Yml 中使用随机数与字符串</title>
      <link>https://zhixiangyuan.github.io/2019/09/19/%E5%A6%82%E4%BD%95%E5%9C%A8-spring-%E7%9A%84-yml-%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Thu, 19 Sep 2019 17:31:13 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/09/19/%E5%A6%82%E4%BD%95%E5%9C%A8-spring-%E7%9A%84-yml-%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>占位符 描述 ${random.value} 取得随机字符串 ${random.int} 取得随机 int 型数据 ${random.long} 取得随机 long 型数据 ${random.int(10)} 取得 10 以内的随机数 ${random.int[10,20]} 取得 10~20 的随机数 ${自定义占位符 or 环境变量} 自定义占位符 or</description>
    </item>
    
    <item>
      <title>如何在 Leetcode 上调试代码</title>
      <link>https://zhixiangyuan.github.io/2019/09/19/%E5%A6%82%E4%BD%95%E5%9C%A8-leetcode-%E4%B8%8A%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Thu, 19 Sep 2019 09:39:08 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/09/19/%E5%A6%82%E4%BD%95%E5%9C%A8-leetcode-%E4%B8%8A%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81/</guid>
      <description>最近经常在 leetcode 上面刷题，不过发现在上面写的代码如果遇到一些 bug 只能肉眼 debug，如果 不能肉眼 debug 出来就比较难受了，还要打开 ide 真实模拟一下。不过今</description>
    </item>
    
    <item>
      <title>ArrayList 使用注意事项</title>
      <link>https://zhixiangyuan.github.io/2019/09/18/arraylist-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Wed, 18 Sep 2019 18:24:57 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/09/18/arraylist-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>1 ArrayList 使用注意事项 如果一边对 ArrayList 中的元素做修改，一边使用 Iterator 对 ArrayList 进行遍历，则会抛出 ConcurrentModificationException 异常。 2 为什么会出现 ConcurrentModificationException 这个异常 通过翻看源码，能够找到下面这段代</description>
    </item>
    
    <item>
      <title>如何介绍一个集合类</title>
      <link>https://zhixiangyuan.github.io/2019/09/18/%E5%A6%82%E4%BD%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E7%B1%BB/</link>
      <pubDate>Wed, 18 Sep 2019 16:02:48 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/09/18/%E5%A6%82%E4%BD%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E7%B1%BB/</guid>
      <description>很多时候，作为一个程序员，仅仅会使用集合类是不够的，我们经常需要向别人介绍集合类，那么，在向别人介绍集合类的时候，我们应该从哪几个角度进行介</description>
    </item>
    
    <item>
      <title>临床中的急性肾功能损伤 Akl 可以通过什么指标预警</title>
      <link>https://zhixiangyuan.github.io/2019/09/17/%E4%B8%B4%E5%BA%8A%E4%B8%AD%E7%9A%84%E6%80%A5%E6%80%A7%E8%82%BE%E5%8A%9F%E8%83%BD%E6%8D%9F%E4%BC%A4-akl-%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E6%8C%87%E6%A0%87%E9%A2%84%E8%AD%A6/</link>
      <pubDate>Tue, 17 Sep 2019 20:25:18 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/09/17/%E4%B8%B4%E5%BA%8A%E4%B8%AD%E7%9A%84%E6%80%A5%E6%80%A7%E8%82%BE%E5%8A%9F%E8%83%BD%E6%8D%9F%E4%BC%A4-akl-%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E6%8C%87%E6%A0%87%E9%A2%84%E8%AD%A6/</guid>
      <description>如果在临床中出现急性肾功能损伤即 Akl（下文均以 Akl 作为替代），那么会导致尿量减少甚至无尿，而由于体液的增加，会导致血钾和电解质紊乱，心电 T 波</description>
    </item>
    
    <item>
      <title>Object 中 hashcode() 与 equals() 的关系</title>
      <link>https://zhixiangyuan.github.io/2019/09/17/object-%E4%B8%AD-hashcode-%E4%B8%8E-equals-%E7%9A%84%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Tue, 17 Sep 2019 17:14:02 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/09/17/object-%E4%B8%AD-hashcode-%E4%B8%8E-equals-%E7%9A%84%E5%85%B3%E7%B3%BB/</guid>
      <description>情况分为以下四种： hashcode 相等，equals 可能相等 hashcode 不相等，equals 一定不相等 equals 相等，hashcode 一定相等 equals 相等说明是同一个对象，所以 hashcode</description>
    </item>
    
    <item>
      <title>Java Byte &amp; 0xFF 的作用</title>
      <link>https://zhixiangyuan.github.io/2019/09/16/java-byte-0xff-%E7%9A%84%E4%BD%9C%E7%94%A8/</link>
      <pubDate>Mon, 16 Sep 2019 14:40:00 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/09/16/java-byte-0xff-%E7%9A%84%E4%BD%9C%E7%94%A8/</guid>
      <description>Java 代码中，经常能够见到 byte &amp;amp; 0xFF 这串代码，这是由于 Java 在处理 byte 的时候，将 byte 当作有符号来处理，所以比如说我们要进行 byte &amp;lt;&amp;lt; 8，如果 byte 的第一位为 0，那么在</description>
    </item>
    
    <item>
      <title>MyBatis Plugin 使用案例</title>
      <link>https://zhixiangyuan.github.io/2019/09/10/mybatis-plugin-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Tue, 10 Sep 2019 07:34:23 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/09/10/mybatis-plugin-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/</guid>
      <description>MyBatis 插件，实现功能的插件又可称之为拦截器，主要提供对 org.apache.ibatis.executor.Executor、org.apach</description>
    </item>
    
    <item>
      <title>MyBatis ObjectFactory 使用案例</title>
      <link>https://zhixiangyuan.github.io/2019/09/10/mybatis-objectfactory-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Tue, 10 Sep 2019 07:02:15 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/09/10/mybatis-objectfactory-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/</guid>
      <description>MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂来完成。默认的对象工厂仅仅是实例化目标类，要么通过默认构造方法，要么在构造方法上参数映射</description>
    </item>
    
    <item>
      <title>MyBatis TypeHandler 使用案例</title>
      <link>https://zhixiangyuan.github.io/2019/09/09/mybatis-typehandler-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Mon, 09 Sep 2019 07:20:41 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/09/09/mybatis-typehandler-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/</guid>
      <description>数据库的数据类型与 Java 中的数据类型存在差异，当需要对两者做特定的转换时，MyBatis 提供了 TypeHandler 来实现转换操作，以下是一个实际案例，通过将 Java 中的</description>
    </item>
    
    <item>
      <title>CAP 简述</title>
      <link>https://zhixiangyuan.github.io/2019/08/23/cap-%E7%AE%80%E8%BF%B0/</link>
      <pubDate>Fri, 23 Aug 2019 14:08:22 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/08/23/cap-%E7%AE%80%E8%BF%B0/</guid>
      <description>CAP 理论是 1998 年，加州大学的计算机科学家 EricBrewer 提出，其中包含三个指标 Consistency Availability Partition tolerance 1 Consistency 一致性 指的是所有数据在同一时刻看到的数据是一致的 all nodes see the same data at the same time</description>
    </item>
    
    <item>
      <title>Equals 方法的重写规则</title>
      <link>https://zhixiangyuan.github.io/2019/08/09/equals-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%E8%A7%84%E5%88%99/</link>
      <pubDate>Fri, 09 Aug 2019 09:24:19 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/08/09/equals-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%E8%A7%84%E5%88%99/</guid>
      <description>equals 方法有一些固定的规则，一些类（例如集合类）会按照规则使用 equals 方法，如果重写的时候不按照这些规则进行重写，那么在使用的时候就可能出现莫名其妙的</description>
    </item>
    
    <item>
      <title>ThreadPoolExecutor 解析</title>
      <link>https://zhixiangyuan.github.io/2019/08/06/threadpoolexecutor-%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 06 Aug 2019 17:26:17 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/08/06/threadpoolexecutor-%E8%A7%A3%E6%9E%90/</guid>
      <description>1 ThreadPoolExecutor 的构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public ThreadPoolExecutor( // 核心线程数，默认不会被回收掉，但是如果设置了 allowCoreThreadTimeOut //</description>
    </item>
    
    <item>
      <title>IntelliJ IDEA 中的五种断点</title>
      <link>https://zhixiangyuan.github.io/2019/08/05/intellij-idea-%E4%B8%AD%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%AD%E7%82%B9/</link>
      <pubDate>Mon, 05 Aug 2019 16:18:58 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/08/05/intellij-idea-%E4%B8%AD%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%AD%E7%82%B9/</guid>
      <description>IntelliJ IDEA 中存在四种断点，分别是行断点、条件断点、方法断点、异常断点、字段观察断点，下面来一一介绍。 1 行断点 行断点，顾名思义，当代码走到断点行的时</description>
    </item>
    
    <item>
      <title>数组的协变与范型的协变</title>
      <link>https://zhixiangyuan.github.io/2019/08/01/%E6%95%B0%E7%BB%84%E7%9A%84%E5%8D%8F%E5%8F%98%E4%B8%8E%E8%8C%83%E5%9E%8B%E7%9A%84%E5%8D%8F%E5%8F%98/</link>
      <pubDate>Thu, 01 Aug 2019 16:02:28 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/08/01/%E6%95%B0%E7%BB%84%E7%9A%84%E5%8D%8F%E5%8F%98%E4%B8%8E%E8%8C%83%E5%9E%8B%E7%9A%84%E5%8D%8F%E5%8F%98/</guid>
      <description>Java 中的数组是支持协变的，而范型不支持协变，先通过下面的代码了解什么是协变。 1 2 3 4 5 6 7 8 9 10 11 12 13 public static void main(String[] args) { // Number 数组可以指向 Integer 数组 // 这就</description>
    </item>
    
    <item>
      <title>父类如何返回子类</title>
      <link>https://zhixiangyuan.github.io/2019/08/01/%E7%88%B6%E7%B1%BB%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E5%AD%90%E7%B1%BB/</link>
      <pubDate>Thu, 01 Aug 2019 14:59:14 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/08/01/%E7%88%B6%E7%B1%BB%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E5%AD%90%E7%B1%BB/</guid>
      <description>以 netty 的 AbstractBootstrap 为例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 1. 父类中定义一个继承自己的范型 B. B extends AbstractBootstrap&amp;lt;B&amp;gt; public abstract class AbstractBootstrap&amp;lt;B extends AbstractBootstrap&amp;lt;B&amp;gt;&amp;gt;{ ... public B method1() { return self(); } public B method2() { return</description>
    </item>
    
    <item>
      <title>由无效缓存引起的内存泄漏</title>
      <link>https://zhixiangyuan.github.io/2019/07/30/%E7%94%B1%E6%97%A0%E6%95%88%E7%BC%93%E5%AD%98%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</link>
      <pubDate>Tue, 30 Jul 2019 20:36:52 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/30/%E7%94%B1%E6%97%A0%E6%95%88%E7%BC%93%E5%AD%98%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</guid>
      <description>在下面这段代码中存在一个内存泄漏的问题，在使用中表现为性能下降，在极端情况下甚至可能出现 OutOfMemoryError。先看代码，看你是否</description>
    </item>
    
    <item>
      <title>ReentrantLock 详解</title>
      <link>https://zhixiangyuan.github.io/2019/07/24/reentrantlock-%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 24 Jul 2019 21:31:26 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/24/reentrantlock-%E8%AF%A6%E8%A7%A3/</guid>
      <description>本文基于 JDK 1.8 1 ReentrantLock 的作用 Java 中已经有了 synchronized 的来进行隐式的加锁和解锁，那还为什么还要引入 ReentrantLock 这把锁呢。这主要是 synchronized 的加锁和解锁操作并不灵活，Reentr</description>
    </item>
    
    <item>
      <title>Unsafe 解析</title>
      <link>https://zhixiangyuan.github.io/2019/07/23/unsafe-%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 23 Jul 2019 20:29:17 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/23/unsafe-%E8%A7%A3%E6%9E%90/</guid>
      <description>本文基于 jdk1.8 Unsafe 位于 sun.misc 包下，提供能直接访问系统内存资源的方法，使得用户能够自主管理内存，使用得当能够提升程序的运行效率。 1 如何获取 Unsafe 实例 下面代码</description>
    </item>
    
    <item>
      <title>Java 线程的生命周期</title>
      <link>https://zhixiangyuan.github.io/2019/07/21/java-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Sun, 21 Jul 2019 20:09:56 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/21/java-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>Java 语言中的线程本质上就是操作系统的线程，Java 创建线程同样是调用操作系统的 API 来创建线程。所以，了解 Java 线程的生命周期的第一步是了解操作系统线</description>
    </item>
    
    <item>
      <title>关于学习</title>
      <link>https://zhixiangyuan.github.io/2019/07/17/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Wed, 17 Jul 2019 20:55:37 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/17/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0/</guid>
      <description>学一个东西，一般从三个角度思考，what、how、why 1 比如说计算机协议 从 what 的角度，所学的是一个什么样的协议，这种协议有怎样的特性，能够解</description>
    </item>
    
    <item>
      <title>通过银行转账问题解说死锁解决方案</title>
      <link>https://zhixiangyuan.github.io/2019/07/17/%E9%80%9A%E8%BF%87%E9%93%B6%E8%A1%8C%E8%BD%AC%E8%B4%A6%E9%97%AE%E9%A2%98%E8%A7%A3%E8%AF%B4%E6%AD%BB%E9%94%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Wed, 17 Jul 2019 09:26:08 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/17/%E9%80%9A%E8%BF%87%E9%93%B6%E8%A1%8C%E8%BD%AC%E8%B4%A6%E9%97%AE%E9%A2%98%E8%A7%A3%E8%AF%B4%E6%AD%BB%E9%94%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>1 如何解决银行转账时的并发问题 当出现 A 将钱转给 B 的时候，什么样的方案可以避免在转账时没有并发问题。先看以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</description>
    </item>
    
    <item>
      <title>Java 解决可见性和有序性问题的方法</title>
      <link>https://zhixiangyuan.github.io/2019/07/16/java-%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 16 Jul 2019 17:24:13 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/16/java-%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>1 Happens-Before 规则 Java 通过提出 Happens-Before 规则来解决可见性和有序性的问题，Happens-Before 的意思是前面一个操作的结果对后续操作是可见的。 1.1 程序的顺序性</description>
    </item>
    
    <item>
      <title>信息的获取方式</title>
      <link>https://zhixiangyuan.github.io/2019/07/16/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Tue, 16 Jul 2019 15:38:16 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/16/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F/</guid>
      <description>信息的获取方式主要分为四种 1 搜索引擎 基本上，碰到的问题都可以先上搜索引擎找一找，如果找不到，再考虑别的渠道，如果能找到就不要再去问别人，浪费</description>
    </item>
    
    <item>
      <title>并发编程需要解决的问题</title>
      <link>https://zhixiangyuan.github.io/2019/07/16/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 16 Jul 2019 10:08:50 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/16/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>1 并发编程需要解决的问题 由于 CPU 从单核变成了多核引发了并发问题，其问题有三。一，每个 CPU 都有自己的缓存，当多个线程运行在不同核的 CPU 上并且修改同一</description>
    </item>
    
    <item>
      <title>TCP：首部结构</title>
      <link>https://zhixiangyuan.github.io/2019/07/12/tcp%E9%A6%96%E9%83%A8%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 12 Jul 2019 15:05:42 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/12/tcp%E9%A6%96%E9%83%A8%E7%BB%93%E6%9E%84/</guid>
      <description>鲁迅曾今说过，TCP 是一个可靠的（reliable）、面向连接的（connection-oriented）、基于字节流（byte-strea</description>
    </item>
    
    <item>
      <title>double 转 BigDecimal 造成的精度丢失</title>
      <link>https://zhixiangyuan.github.io/2019/07/10/double-%E8%BD%AC-bigdecimal-%E9%80%A0%E6%88%90%E7%9A%84%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1/</link>
      <pubDate>Wed, 10 Jul 2019 16:07:14 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/10/double-%E8%BD%AC-bigdecimal-%E9%80%A0%E6%88%90%E7%9A%84%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1/</guid>
      <description>1 2 3 4 5 6 public static void main(String[] args) { double d1 = 36.8d; double d2 = 36.5d; BigDecimal subtract = new BigDecimal(d1).subtract(new BigDecimal(d2)); System.out.println(subtract); } 对于上述类型的计算会得到结果 0.29999999999999715782905695</description>
    </item>
    
    <item>
      <title>IP 协议</title>
      <link>https://zhixiangyuan.github.io/2019/07/09/ip-%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Tue, 09 Jul 2019 21:06:22 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/09/ip-%E5%8D%8F%E8%AE%AE/</guid>
      <description>1 网际协议 IP 简介 IP 协议提供不可靠的、无连接的数据包传输 不可靠指的是从客户端发到目标端的数据包对方可能会收不到 无连接指的是发送的每个数据包都是</description>
    </item>
    
    <item>
      <title>用户数据报协议：UDP</title>
      <link>https://zhixiangyuan.github.io/2019/07/09/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEudp/</link>
      <pubDate>Tue, 09 Jul 2019 16:12:09 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/09/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEudp/</guid>
      <description>1 UDP 协议简介 UDP 是一种面向数据包协议，应用层向下传递的每一次操作都会产生一个 UDP 数据包，这一个 UDP 数据包会组装成一份 IP 数据包，这里是一一对应的关系</description>
    </item>
    
    <item>
      <title>学习路径</title>
      <link>https://zhixiangyuan.github.io/2019/07/09/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Tue, 09 Jul 2019 09:26:50 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/09/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</guid>
      <description>1 学习路径 今天，了解到一个很有意思的词，学习路径。 学习路径在我的理解当中，便是沿着若干个学习目标，通过不断达成学习目标最终完成学习的过程。 光</description>
    </item>
    
    <item>
      <title>Java Gzip 的简单封装</title>
      <link>https://zhixiangyuan.github.io/2019/07/04/java-gzip-%E7%9A%84%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85/</link>
      <pubDate>Thu, 04 Jul 2019 14:50:20 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/04/java-gzip-%E7%9A%84%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85/</guid>
      <description>本文基于 Jdk 1.8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.util.zip.GZIPInputStream; import java.util.zip.GZIPOutputStream; public class GzipUtil { /** *</description>
    </item>
    
    <item>
      <title>Java 性能优化</title>
      <link>https://zhixiangyuan.github.io/2019/07/02/java-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Tue, 02 Jul 2019 16:22:25 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/02/java-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>1 明确是否需要优化以及要优化到什么程度 首先需要在实践中检测代码是否需要优化，如果不需要优化，那么优化可能占用大量时间，而且优化完了也不会有任</description>
    </item>
    
    <item>
      <title>一次内存泄漏排查的经历</title>
      <link>https://zhixiangyuan.github.io/2019/07/01/%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5%E7%9A%84%E7%BB%8F%E5%8E%86/</link>
      <pubDate>Mon, 01 Jul 2019 13:14:38 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/01/%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5%E7%9A%84%E7%BB%8F%E5%8E%86/</guid>
      <description>开发环境: JDK: 1.8 Netty: 4.1.21.Final 1 起因 由于我之前写过一个接收医疗设备数据的项目，于是为了压力测试，就又按照该协议实现了一个发送设备数据的项目。这个项目在使</description>
    </item>
    
    <item>
      <title>Centos 配置无密登录</title>
      <link>https://zhixiangyuan.github.io/2019/01/17/centos-%E9%85%8D%E7%BD%AE%E6%97%A0%E5%AF%86%E7%99%BB%E5%BD%95/</link>
      <pubDate>Thu, 17 Jan 2019 20:34:37 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/01/17/centos-%E9%85%8D%E7%BD%AE%E6%97%A0%E5%AF%86%E7%99%BB%E5%BD%95/</guid>
      <description>生成密钥方法 ssh-keygen -t rsa // 一路回车 cat id_rsa.pub &amp;gt;&amp;gt; authorized_keys 配置权限 chmod 700 /home/hadoop chmod 700 -R ~/.ssh chmod 600 authorized_keys</description>
    </item>
    
    <item>
      <title>关于 sshd 的坑</title>
      <link>https://zhixiangyuan.github.io/2019/01/16/%E5%85%B3%E4%BA%8E-sshd-%E7%9A%84%E5%9D%91/</link>
      <pubDate>Wed, 16 Jan 2019 20:30:59 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/01/16/%E5%85%B3%E4%BA%8E-sshd-%E7%9A%84%E5%9D%91/</guid>
      <description>1 sshd 死都打不开 试试先用 /usr/sbin/sshd stop 关掉再 start 看看行不行 莫名其妙，直接运行 /usr/sbin/sshd 就好了 1.1 开启 sshd /usr/sbin/sshd start 1.2 sshd 的配置文件权限必须在 root 下为 600 才行 配置文件在 /etc/ssh 目录下，目</description>
    </item>
    
    <item>
      <title>Sftp 命令小记</title>
      <link>https://zhixiangyuan.github.io/2019/01/14/sftp-%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Mon, 14 Jan 2019 20:26:53 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/01/14/sftp-%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</guid>
      <description>sftp 命令会先连接到服务器，然后再下载文件 登陆命令 sftp &amp;lt;username&amp;gt;@&amp;lt;ip&amp;gt; 下载命令 递归下载 `get -r &amp;lt;$文件&amp;gt; &amp;lt;$本地路径&amp;gt;</description>
    </item>
    
    <item>
      <title>Linux 下误删 Secure 文件，系统不记录日志问题</title>
      <link>https://zhixiangyuan.github.io/2019/01/13/linux-%E4%B8%8B%E8%AF%AF%E5%88%A0-secure-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8D%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 13 Jan 2019 20:16:21 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/01/13/linux-%E4%B8%8B%E8%AF%AF%E5%88%A0-secure-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8D%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%E9%97%AE%E9%A2%98/</guid>
      <description>第一步创建文件 touch /var/log/secure 第二步修改权限 chmod 600 /var/log/secure 第三步重启服务 service sshd restart service syslog(rsyslog) restart 注意：如果不重启服务的话，原来的程序依然向被删除的文件中写入数据，那么新建的</description>
    </item>
    
    <item>
      <title>Docker 常用命令</title>
      <link>https://zhixiangyuan.github.io/2019/01/12/docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sat, 12 Jan 2019 19:56:52 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/01/12/docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>保存镜像 docker commit &amp;lt;$container_id&amp;gt; &amp;lt;$image_name&amp;gt; 使用镜像新建容器 1 2 3 4 5 6 7 8 9 10 11 docker run # 以下是一些可选项 # 这是两个参数，一个是 -i：交互式操作，一个是 -t 终端 # 使用这个选</description>
    </item>
    
    <item>
      <title>求数组中间的数据个数</title>
      <link>https://zhixiangyuan.github.io/2018/12/17/%E6%B1%82%E6%95%B0%E7%BB%84%E4%B8%AD%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Mon, 17 Dec 2018 23:18:57 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2018/12/17/%E6%B1%82%E6%95%B0%E7%BB%84%E4%B8%AD%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0/</guid>
      <description>1 求范围内的数字个数 求 0 和 4 中间的数字个数 1.1 既不包含 0，也不包含 4，即 (0,4) 4 - 0 - 1 = 3 1.2 包含 0 或 4，即 (0,4] 或是 [0,4) 4 - 0 = 4 1.3 既包含 0 又包含 4，</description>
    </item>
    
    <item>
      <title>数据库事务小记</title>
      <link>https://zhixiangyuan.github.io/2018/11/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Sat, 24 Nov 2018 14:30:14 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2018/11/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%B0%8F%E8%AE%B0/</guid>
      <description>1 为什么会有数据库事务 数据库在没有事务的情况下进行读写，可能出现脏读、不可重复读与幻读三种异常，而为了解决这三种异常，便引出了数据库事务，首</description>
    </item>
    
    <item>
      <title>Javap 命令的使用</title>
      <link>https://zhixiangyuan.github.io/2018/11/05/javap-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 05 Nov 2018 10:43:36 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2018/11/05/javap-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>通过 javap 命令可以反编译 .class 文件，实际使用的时候 javap 后面的类名加与不加 .class 都可以。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -help --help -? 打印使用信息（也就是打印图中所示</description>
    </item>
    
    <item>
      <title>final、finally、finalize 的异同</title>
      <link>https://zhixiangyuan.github.io/2018/10/17/finalfinallyfinalize-%E7%9A%84%E5%BC%82%E5%90%8C/</link>
      <pubDate>Wed, 17 Oct 2018 16:40:23 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2018/10/17/finalfinallyfinalize-%E7%9A%84%E5%BC%82%E5%90%8C/</guid>
      <description>1 final final 可以用来修饰类、方法、变量 1.1 final 修饰类 final 修饰 class 代表类不可以被继承 1.2 final 修饰变量 final 修饰的变量在初始化之后不能被再次赋值 1.3 final 修饰方法 final 修饰方法</description>
    </item>
    
    <item>
      <title>Exception 与 Error 的异同</title>
      <link>https://zhixiangyuan.github.io/2018/10/16/exception-%E4%B8%8E-error-%E7%9A%84%E5%BC%82%E5%90%8C/</link>
      <pubDate>Tue, 16 Oct 2018 11:26:50 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2018/10/16/exception-%E4%B8%8E-error-%E7%9A%84%E5%BC%82%E5%90%8C/</guid>
      <description>Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有继承了 Throwable 的类才可以被 throw 或者 catch，它是异常处理机制的基本组成类型。Exception 是程序正常运行中，可</description>
    </item>
    
    <item>
      <title>sed 小记</title>
      <link>https://zhixiangyuan.github.io/2018/10/04/sed-%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Thu, 04 Oct 2018 16:21:59 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2018/10/04/sed-%E5%B0%8F%E8%AE%B0/</guid>
      <description>1 sed 的工作流程 sed 逐行处理文件或输入，默认不会修改文件，除非使用 shell 重定向保存结果。 工作流程： 将正在处理的行保存在一个临时缓存区中（也称为模式空</description>
    </item>
    
    <item>
      <title>grep 小记</title>
      <link>https://zhixiangyuan.github.io/2018/09/25/grep-%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Tue, 25 Sep 2018 15:02:04 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2018/09/25/grep-%E5%B0%8F%E8%AE%B0/</guid>
      <description>grep -A [line num]，向下显示多少行，after-context 缩写 -B [line num]，向上显示多少行，before-context 缩写 -C [line num]，上</description>
    </item>
    
    <item>
      <title>tar &amp; scp 小记</title>
      <link>https://zhixiangyuan.github.io/2018/09/24/tar-scp-%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Mon, 24 Sep 2018 17:35:38 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2018/09/24/tar-scp-%E5%B0%8F%E8%AE%B0/</guid>
      <description>1 scp 命令 上传：scp [文件路径] [用户名]@[IP 地址]:[服务器路径] 下载：scp [用户名]@[IP 地址]:[文件路径] [本地路径] 2 tar 命</description>
    </item>
    
    <item>
      <title>HashMap 不得不说的故事</title>
      <link>https://zhixiangyuan.github.io/2018/09/03/hashmap-%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E6%95%85%E4%BA%8B/</link>
      <pubDate>Mon, 03 Sep 2018 10:13:43 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2018/09/03/hashmap-%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E6%95%85%E4%BA%8B/</guid>
      <description>本文基于 Jdk 1.8 1 什么是 HashMap 要理解这个问题，首先需要理解什么是 Hash 以及什么是 Map 1.1 什么是 Hash Hash 是一种散列算法，用于确定关键字到指定位置的对应关系 1.2 什么是</description>
    </item>
    
    <item>
      <title>int 入栈指令 iconst、bipush、sipush、ldc</title>
      <link>https://zhixiangyuan.github.io/2018/08/11/int-%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4-iconstbipushsipushldc/</link>
      <pubDate>Sat, 11 Aug 2018 18:47:43 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2018/08/11/int-%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4-iconstbipushsipushldc/</guid>
      <description>1 前言 本文介绍 int 数值入栈指令 iconst、bipush、sipubh、Idc。 根据 int 取值不同分为以下几种可能性： iconst: [-1, 5] bipush: [-128, -2]∪[6, 127] sipush:</description>
    </item>
    
  </channel>
</rss>