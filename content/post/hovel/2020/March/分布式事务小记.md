---
title: "分布式事务小记"
# date: 2020-03-01T11:08:42+08:00
date: 2020-02-01T11:08:42+08:00
keywords: []
description: ""
tags: [
    "分布式事务"
]
categories: [
    "杂货铺"
]
autoCollapseToc: false
author: "yuanzx"
---

分布式事务解决的核心问题是数据一致性的问题，根据 cap 理论可知一致性、可用性、分区容错性三者只能选其二，所以在实践中需要对此做出权衡。目前解决分布式事务的模型有 M/S、MM、2PC/3PC、paxos。

M/s 指的是 master/slave，master 作为可读写的节点，slave 作为只读节点，slave 定时去 master 上拉取最新数据，当 master 挂掉的时候集群便不能写，必须要等 master 恢复过来，否则便可能出现数据丢失。

MM 指的是 master/master，有两个以及两个以上的节点作为写节点，写节点之间相互拉取最新的数据，这种模式在极端情况下同样可能出现数据丢失的问题。

2PC 指的是两阶段提交，该模型有两个角色，分别是事务管理器和资源管理器，事务管理器首先向所有的资源管理器发出预提交命令，此时资源管理器需要写 redo log、undo log，当执行成功后向事务管理器回复确认，当事务管理器收到所有的资源管理器的确认后，然后向所有的资源管理器发出提交事务命令。这个方式有一些缺陷，其中一个很严重的问题是当整个流程执行到向资源管理器发送提交事务命令时，如果事务管理器挂掉了，那么资源管理器便不知道该怎么办了，同时还锁死了资源。

3PC 是对 2PC 的改进，总共分为三个阶段，第一阶段先询问一下，但是不锁资源，后面两个阶段和 2PC 的阶段相同，这种改进的好处是如果第一阶段所有节点返回成功，那么有理由相信成功提交的概率很大。如果有节点返回失败，那么也不会锁资源，能提高吞吐量。

paxos 算法也分为两个阶段，在第一阶段提案者向所有的节点发出 prepare request，关于所修改的数据有一个提案号，节点在接收到提案后会比较提案号，如果该提案号是最新的，那么便接受该请求，并向提案者回复确认，在第二阶段当提案者收到超过半数节点的确认后，便会向所有的节点发布 accept request，同样需要带上提案号，当节点收到 accept request 后，如果提案号是最大的，那么节点便会修改这个值，如果发现自己有一个更大的提案号那么，节点便会拒绝修改。

paxos 的这种方式要求节点数目必须是奇数才能满足超过半数节点的确认这样的要求，这里的确认是包含发出请求的节点的，这样才能满足奇数的要求。

下图是对于这几种方式的一个汇总，分别比较了一致性、事务、延迟、吞吐量、是否有数据丢失、失败时是否可读写。

![](/hub/2020/March/1.jpg)

# 参考文章

1. [分布式系统的事务处理](https://coolshell.cn/articles/10910.html)