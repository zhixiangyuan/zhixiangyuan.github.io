---
title: "Linux 中的系统调用"
date: 2019-10-14T10:05:02+08:00
keywords: []
description: ""
tags: [
    "linux"
]
categories: [
    "杂货铺"
]
autoCollapseToc: false
author: "yuanzx"
---

# 1 系统调用

1. fork: 创建进程
2. execve: 执行任务
3. waitpid: 通过将子进程的进程号传给它来了解子进程运行是否完成，是否成功
4. brk: 分配一块与原来堆数据连在一起的内存空间
5. mmap: 分配一块新的堆内存空间
6. open: 打开文件
7. close: 关闭文件
8. create: 创建文件
9. lseek: 打开文件以后，跳到文件的某个位置
10. read: 读取文件
11. write: 写入文件

# 2 一切皆文件

1. 启动一个进程，需要一个进程文件，这是一个**二进制文件**
2. 交互命令行上的输出是标准输出 **stdout 文件**
3. 一个进程的输出可以作为另一个进程的输入，这种方式称为管道，**管道也是一个文件**
4. 进程可以通过网络和其他进程进行通信，建立的 **Socket 也是一个文件**
5. 进程需要访问外部设备，**设备也是一个文件**
6. 文件都被存储在文件夹中，**文件夹也是一个文件**
7. 进程运行起来，要想看到进程运行的情况，会在 /proc 下面有对应的**进程号**，还是一些列文件

每个文件都有一个文件描述符（File Descriptor），这是一个整数。有了这个文件描述符，我们就可 hi使用系统调用，查看或者干预进程运行的方方面面。

# 3 进程间通信

两种方式，消息队列或者是内存共享

## 3.1 消息队列

1. msgget: 创建队列
2. msgsnd: 生产者将消息发送到队列
3. msgrcv: 消费者从队列中取出消息消费

## 3.2 共享内存

1. shmget: 创建一个共享内存块
2. shmat: 将共享内存映射到自己的内存空间，然后就可以读写了

# 4 信号量

1. sem_wait: 抢占信号量
2. sem_post: 释放信号量

# 5 Glibc 库

Glibc 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库。Glibc 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了操作系统提供的系统服务，即系统调用的封装。

每个特定的系统调用对应了至少一个 Glibc 封装的库函数，比如说，系统提供的打开文件系统调用 sys_open 对应的是 Glibc 中的 open 函数。

Glibc 一个单独的 API 可能调用多个系统调用，比如说，Glibc 提供的 printf 函数就会调
用如 sys_open、sys_mmap、sys_write、sys_close 等等系统调用。

多个 API 也可能只对应同一个系统调用，如 Glibc 下实现的 malloc、calloc、free 等
函数用来分配和释放内存，都利用了内核的 sys_brk 的系统调用。

# 6 系统调用源文件位置

上述系统调用都定义在 **unistd_64.h** 这个文件中，我所下载的 Linux 版本这个文件在 **arch/sh/include/uapi/asm/unistd_64.h** 位置

Linux 内核下载地址: https://www.kernel.org/