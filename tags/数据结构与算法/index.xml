<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构与算法 on 养猪场</title>
    <link>https://zhixiangyuan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 数据结构与算法 on 养猪场</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>yuanzx</copyright>
    <lastBuildDate>Sat, 01 Feb 2020 21:33:13 +0800</lastBuildDate>
    
	<atom:link href="https://zhixiangyuan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>01背包问题</title>
      <link>https://zhixiangyuan.github.io/2020/02/01/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 01 Feb 2020 21:33:13 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/02/01/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public static void main(String[] args) { // 重量 int[] weight = new int[]{4, 6, 2, 2, 5, 1}; // 价值 int[] value = new int[]{8, 10, 6, 3, 7,</description>
    </item>
    
    <item>
      <title>使用数组构造完全二叉树</title>
      <link>https://zhixiangyuan.github.io/2020/01/27/%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E6%9E%84%E9%80%A0%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 27 Jan 2020 19:06:37 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/27/%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E6%9E%84%E9%80%A0%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * 创建一颗树高为 treeHeight 的完全二叉树 * * @param treeHeight 树高 * @return 以数组形式存储的完全二</description>
    </item>
    
    <item>
      <title>B&#43;树和 B 树的区别</title>
      <link>https://zhixiangyuan.github.io/2019/10/27/b-%E6%A0%91%E5%92%8C-b-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 27 Oct 2019 11:26:24 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/27/b-%E6%A0%91%E5%92%8C-b-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>B 树的非叶子结点存储实际记录的指针 B+ 树的非叶子节点不存储实际记录的指针，所有的指针均存储在叶子结点，并且叶子结点使用指针串了起来，形成了链表</description>
    </item>
    
    <item>
      <title>快速排序</title>
      <link>https://zhixiangyuan.github.io/2019/10/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 18 Oct 2019 13:56:39 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description>快速排序使用分治思想，实际实现过程和二叉树的前序遍历很像，在第一次碰到节点时进行遍历分区，然后再对子分区进行遍历分区，直到分区中只有一个节点</description>
    </item>
    
    <item>
      <title>归并排序</title>
      <link>https://zhixiangyuan.github.io/2019/10/17/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Thu, 17 Oct 2019 00:36:50 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/17/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</guid>
      <description>归并排序通过对数组进行二叉树式的拆分最后再合并，完成了其排序过程，并将时间复杂度下降到了 O(nlogn) 的程度，下面是一个数组索引 0 - 9 的数组的拆分的过程</description>
    </item>
    
    <item>
      <title>跳表</title>
      <link>https://zhixiangyuan.github.io/2019/10/16/%E8%B7%B3%E8%A1%A8/</link>
      <pubDate>Wed, 16 Oct 2019 10:51:09 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/16/%E8%B7%B3%E8%A1%A8/</guid>
      <description>1 跳表的数据结构 跳表是在链表上做的改善，解决了链表查找时间复杂度为 O(n) 的问题，改善之后的跳表可以像二分查找一样，实现时间复杂度为 O(logn) 的效果。 对于</description>
    </item>
    
    <item>
      <title>堆的应用</title>
      <link>https://zhixiangyuan.github.io/2019/10/15/%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Tue, 15 Oct 2019 14:52:36 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/15/%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>1 优先级队列 优先级队列，我的理解就是一个有排序顺序的队列，对于一般的队列，都是 FIFO，但是对于优先级队列，队列内部的顺序并不是 FIFO 的，在入队</description>
    </item>
    
    <item>
      <title>堆和堆排序</title>
      <link>https://zhixiangyuan.github.io/2019/10/14/%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Mon, 14 Oct 2019 16:36:36 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/14/%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</guid>
      <description>1 堆 堆是一种特殊的树，它需要满足两个要求： 堆是一棵完全二叉树 堆中每一个节点的值必须大于等于（或小于等于）其子树中每个节点的值 根据第二个特性可</description>
    </item>
    
    <item>
      <title>平衡二叉查找树</title>
      <link>https://zhixiangyuan.github.io/2019/10/13/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</link>
      <pubDate>Sun, 13 Oct 2019 15:24:13 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/13/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</guid>
      <description>二叉树的时间复杂度在理想状况下是 O(logn) 但是在频繁的动态更新下可能就退化成 O(n) 或者接近 O(n) 了，这个问题不解决，二叉树的性能就太差了，由此便引出了平衡二</description>
    </item>
    
    <item>
      <title>二叉树基础</title>
      <link>https://zhixiangyuan.github.io/2019/10/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 11 Oct 2019 09:51:42 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80/</guid>
      <description>1 树的基础知识 节点的高度：节点到叶子结点的边数 节点的深度：跟节点到这个节点经历的边数 节点的层数：节点的深度 + 1 树的高度：根节点的高度 2 二叉树</description>
    </item>
    
    <item>
      <title>冒泡排序、插入排序、选择排序</title>
      <link>https://zhixiangyuan.github.io/2019/07/17/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 17 Jul 2019 21:59:06 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/17/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</guid>
      <description>1. 冒泡排序 1.1 原理 通过遍历所有元素，判断相邻的两个元素是否满足大小关系，如果不满足则进行交换，重复 n 次，就完成 n 个数据的排序工作。 1.2 代码实现 1</description>
    </item>
    
    <item>
      <title>最好、最坏、平均、均摊时间复杂度</title>
      <link>https://zhixiangyuan.github.io/2019/07/11/%E6%9C%80%E5%A5%BD%E6%9C%80%E5%9D%8F%E5%B9%B3%E5%9D%87%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
      <pubDate>Thu, 11 Jul 2019 10:17:37 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/11/%E6%9C%80%E5%A5%BD%E6%9C%80%E5%9D%8F%E5%B9%B3%E5%9D%87%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
      <description>1 最好、最坏时间复杂度 先看下述代码 1 2 3 4 5 6 7 8 9 10 11 int find(int[] array, int x) { int pos = -1; int n = array.length; for (int i = 0; i &amp;lt; n; i++) { if (array[i] == x) { pos = i; break; } } return pos; } 该代码用</description>
    </item>
    
    <item>
      <title>时间复杂度与空间复杂度</title>
      <link>https://zhixiangyuan.github.io/2019/07/10/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
      <pubDate>Wed, 10 Jul 2019 18:36:23 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/10/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
      <description>1 时间复杂度 分析程序时间复杂度的时候只需要关注循环中的代码即可 1.1 常见的时间复杂度 常见的时间复杂度有 O(1), O(n), O(logn), O(nlogn), O(\(n^2\)).. O(\(n^k\)), O(\(2^n\)), O(n!) 其中 O(\(2^n\)) 和 O(n!) 在数据规模增大时</description>
    </item>
    
  </channel>
</rss>